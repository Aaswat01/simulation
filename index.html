<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Eco Driving Dashboard</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
<style>
*{box-sizing:border-box;margin:0;padding:0;}
body{
background:radial-gradient(circle at top left,#0f1c2e,#1c2b44,#2a3b60);
font-family:"Segoe UI",Arial,sans-serif;color:#fff;
height:100vh;display:flex;flex-direction:column;overflow:hidden;
}
/* === HEADER === */
.ai-tip-box{flex:0 0 auto;background:#ffa500;color:#000;border-radius:1vh;
margin:1vh 2vw;padding:1.5vh 1vw;text-align:center;font-weight:bold;
font-size:clamp(1rem,2vw,1.6rem);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.stats-row{display:flex;justify-content:space-evenly;align-items:stretch;
flex-wrap:wrap;gap:1vh;margin:0 1vw;}
.stat-card{flex:1;min-width:120px;max-width:180px;background:rgba(28,34,48,0.95);
border-radius:1vh;padding:1vh;display:flex;flex-direction:column;justify-content:center;
align-items:center;text-align:center;border:1px solid rgba(255,255,255,0.2);
box-shadow:0 0.3vh 1vh rgba(0,0,0,0.4);}
.stat-label{font-size:0.9rem;opacity:0.8;}
.stat-value{font-size:1.3rem;font-weight:bold;margin-top:0.3rem;}
.speed-box{background:#4e79a7;}
.gear-box{background:#76b7b2;color:#000;}
.throttle-box{background:#2ca02c;color:#000;}
/* === SEARCH === */
.search-row{display:flex;align-items:center;justify-content:center;gap:1vw;margin:1vh 2vw;position:relative;}
#searchInput{flex:1;max-width:70%;padding:0.8vh 1vw;font-size:1rem;border-radius:1vh;
border:none;outline:none;}
#micBtn{background:#ff4c4c;color:#fff;border:none;border-radius:1vh;padding:0.8vh 1.2vw;
font-weight:bold;cursor:pointer;box-shadow:0 0.4vh 1vh rgba(0,0,0,0.3);}
#suggestBox{position:absolute;top:100%;left:10%;width:80%;background:rgba(0,0,0,0.9);
border-radius:1vh;max-height:40vh;overflow-y:auto;z-index:2000;display:none;}
.suggest-item{padding:0.8vh 1vw;border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer;}
.suggest-item:hover{background:rgba(255,255,255,0.1);}
/* === MAIN (Map now fills space) === */
.main-section{flex:1;display:flex;flex-direction:column;gap:1vh;padding:0 2vw 1vh;}
.map-container{flex:1;position:relative;border-radius:1vh;overflow:hidden;
border:1px solid rgba(255,255,255,0.2);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.map{width:100%;height:100%;}
#map-toggle{position:absolute;top:1vh;right:1vh;z-index:1000;background:#ff8c00;
border:none;border-radius:1vh;padding:0.5vh 1vw;font-weight:bold;cursor:pointer;color:#000;}
/* === ROUTE PANEL === */
#routePanel{position:absolute;bottom:2vh;left:2vw;width:270px;max-height:42vh;
overflow-y:auto;background:rgba(0,0,0,0.6);border-radius:1vh;padding:0.5vh;color:#fff;z-index:999;}
.route-box{margin-bottom:0.8vh;border-radius:1vh;overflow:hidden;background:rgba(255,255,255,0.05);backdrop-filter:blur(6px);box-shadow:0 0.4vh 1vh rgba(0,0,0,0.5);}
.route-header{padding:0.6vh 0.6vw;font-weight:bold;display:flex;justify-content:space-between;
align-items:center;color:#fff;font-size:0.9rem;}
.route-content{background:rgba(255,255,255,0.1);padding:0.4vh 0.6vw;font-size:0.85rem;max-height:30vh;overflow-y:auto;transition:all 0.3s ease;}
.route-step{padding:0.4vh 0.3vw;margin-bottom:0.4vh;border-bottom:1px solid rgba(255,255,255,0.1);}
.route-step:hover{background:rgba(255,255,255,0.15);}
</style>
</head>
<body>
<div class="ai-tip-box" id="ai-tip">Drive smoothly</div>
<div class="stats-row">
Â  <div class="stat-card speed-box"><div class="stat-label">Speed</div><div class="stat-value" id="speed">0 km/h</div></div>
Â  <div class="stat-card gear-box"><div class="stat-label">Gear</div><div class="stat-value" id="gear">N</div></div>
Â  <div class="stat-card throttle-box"><div class="stat-label">Throttle</div><div class="stat-value" id="throttle">0%</div></div>
</div>

<div class="search-row">
Â  <input type="text" id="searchInput" placeholder="Search destination...">
Â  <button id="micBtn">ðŸŽ¤</button>
Â  <div id="suggestBox"></div>
</div>

<div class="main-section">
Â  <div class="map-container">
Â  Â  <div id="map" class="map"></div>
Â  Â  <button id="map-toggle">Full Map</button>
Â  Â  <div id="routePanel"></div>
Â  </div>
</div> <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script>
/* ===== Map Init ===== */
const map=L.map('map').setView([19.076,72.8777],13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'Â© OSM'}).addTo(map);
const carIcon=L.icon({iconUrl:'https://cdn-icons-png.flaticon.com/512/3097/3097144.png',iconSize:[42,42]});
let userMarker=null,waypoints=[],waypointMarkers=[],routes=[],totalFuel=0;
const colors=['#FF6B6B','#4DA6FF','#FFD93D','#6BCB77','#FF8C00','#9B59B6','#00BFA5'];

/* ===== Eco Advisor (Unchanged) ===== */
function ecoAdvisor(dist,elev,turnText){
Â  Â  const t=(turnText||'').toLowerCase();
Â  Â  let tip="Drive smoothly", speed=50, gear=3, throttle=45;

Â  Â  // Road type detection
Â  Â  const roadType=t.includes("highway")?"highway":
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â t.includes("city")?"city":
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â t.includes("roundabout")?"roundabout":"normal";

Â  Â  if(t.includes("left")||t.includes("right")) { speed=25; gear=2; throttle=35; tip="Slow for turn"; }
Â  Â  else if(elev>6) { speed=30; gear=2; throttle=55; tip="Downhill"; }
Â  Â  else if(elev<-6){ speed=55; gear=5; throttle=25; tip="Uphill "; }
Â  Â  else if(dist>800){ speed=65; gear=5; throttle=50; tip="Long straight â€” steady speed"; }
Â  Â  else if(dist>300){ speed=55; gear=4; throttle=45; tip="Smooth cruising"; }

Â  Â  // Adjustments by road type
Â  Â  if(roadType==="highway"){ speed=Math.min(speed,80); gear=Math.max(gear,5); throttle=50; tip+=" â€” highway"; }
Â  Â  else if(roadType==="city"){ speed=Math.min(speed,50); gear=Math.min(gear,3); throttle=40; tip+=" â€” city"; }
Â  Â  else if(roadType==="roundabout"){ speed=25; gear=2; throttle=35; tip+=" â€” roundabout"; }

Â  Â  // Fuel saving hints
Â  Â  if(speed>70) tip="High speed â€” reduce for fuel saving";
Â  Â  if(throttle>60 && elev>3) tip="High throttle uphill â€” shift earlier";

Â  Â  return {speed, gear, throttle, tip};
}

/* ===== Driver Behavior Monitoring (Unchanged) ===== */
let driverStats = { overspeed: 0, harshAccel: 0, totalPoints: 0 };
let spokenWarnings = new Set();Â  // Track unique warnings spoken

function updateDriverBehavior(currentSpeed, eco) {
Â  Â  driverStats.totalPoints++;
Â  Â  let warnings = [];

Â  Â  // Overspeed detection
Â  Â  if (currentSpeed > eco.speed + 5) {
Â  Â  Â  Â  driverStats.overspeed++;
Â  Â  Â  Â  if (!spokenWarnings.has('overspeed')) {
Â  Â  Â  Â  Â  Â  warnings.push("Overspeeding detected");
Â  Â  Â  Â  Â  Â  spokenWarnings.add('overspeed');
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // Harsh acceleration detection
Â  Â  const lastThrottle = parseFloat(document.getElementById("throttle").dataset.lastThrottle || 0);
Â  Â  const currentThrottle = eco.throttle;
Â  Â  if (Math.abs(currentThrottle - lastThrottle) > 25) {
Â  Â  Â  Â  driverStats.harshAccel++;
Â  Â  Â  Â  if (!spokenWarnings.has('harshAccel')) {
Â  Â  Â  Â  Â  Â  warnings.push("Harsh acceleration");
Â  Â  Â  Â  Â  Â  spokenWarnings.add('harshAccel');
Â  Â  Â  Â  }
Â  Â  }
Â  Â  document.getElementById("throttle").dataset.lastThrottle = currentThrottle;

Â  Â  // Habitual warnings
Â  Â  if (driverStats.overspeed / driverStats.totalPoints > 0.3 && !spokenWarnings.has('overspeedHabit')) {
Â  Â  Â  Â  warnings.push("Overspeed detected!");
Â  Â  Â  Â  spokenWarnings.add('overspeedHabit');
Â  Â  }

Â  Â  // Voice alert (Eco tip is handled separately in adaptiveAIDashboard now)
Â  Â  if ('speechSynthesis' in window && warnings.length) {
Â  Â  Â  Â  const msg = new SpeechSynthesisUtterance(warnings.join(" "));
Â  Â  Â  Â  msg.rate = 1; msg.pitch = 1;
Â  Â  Â  Â  speechSynthesis.speak(msg);
Â  Â  }
}

function dynamicEcoAdvisor(currentSpeed, slopeAhead, distToNextStep){
Â  Â  // Determine speed & throttle purely based on elevation change
Â  Â  let tip = "Drive smoothly", speed = 50, gear = 3, throttle = 45;
Â  Â  if(slopeAhead > 5){ speed = Math.min(currentSpeed + 10, 70); throttle = 55; tip = "Uphill â€” maintain momentum"; gear = 4; }
Â  Â  else if(slopeAhead < -5){ speed = Math.max(currentSpeed - 10, 25); throttle = 25; tip = "Downhill â€” control speed"; gear = 3; }
Â  Â  else { speed = 50; throttle = 45; tip = "Smooth road"; gear = 3; }

Â  Â  // Longer straight: slight speed increase
Â  Â  if(distToNextStep > 800) speed = Math.min(speed + 10, 70);
Â  Â  // Short: slow down
Â  Â  if(distToNextStep < 100) speed = Math.max(speed - 10, 25);

Â  Â  return {speed, gear, throttle, tip};
}

async function getElevations(coords){
Â  Â  try{
Â  Â  Â  Â  const locs=coords.map(p=>`${p.lat},${p.lng}`).join('|');
Â  Â  Â  Â  const r=await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(locs)}`);
Â  Â  Â  Â  const d=await r.json();
Â  Â  Â  Â  return d.results.map(x=>x.elevation);
Â  Â  }catch{return new Array(coords.length).fill(0);}
}

/* ===== Multi-Step Route Awareness (Unchanged) ===== */
async function getUpcomingSteps(latlng, maxSteps=5){
Â  if(!routes.length) return [];
Â  const upcomingSteps=[];
Â  routes.forEach(r=>{
Â  Â  let nearestIdx=-1, minDist=Infinity;
Â  Â  r.steps.forEach((s,i)=>{
Â  Â  Â  const d=latlng.distanceTo([s.lat,s.lng]);
Â  Â  Â  if(d<minDist){ minDist=d; nearestIdx=i; }
Â  Â  });
Â  Â  if(nearestIdx!==-1){
Â  Â  Â  for(let j=nearestIdx; j<Math.min(r.steps.length, nearestIdx+maxSteps); j++){
Â  Â  Â  Â  upcomingSteps.push(r.steps[j]);
Â  Â  Â  }
Â  Â  }
Â  });
Â  return upcomingSteps;
}

/* ====== Step-by-Step AI Voice Guidance & Dashboard Update (FIXED) ====== */
let activeRouteIndex = null;
let currentStepIndex = 0;
let nextStepReady = true;

async function adaptiveAIDashboard(latlng, heading) {
Â  const currentSpeed = calculateGPSSpeed(latlng);
Â  const slopeData = await predictElevationAhead(latlng, heading);
Â  const slope = slopeData.slope;

Â  // Base eco tip
Â  let eco = ecoAdvisor(0, slope, "");

Â  // If thereâ€™s an active route
Â  if (routes.length && activeRouteIndex !== null) {
Â  Â  const route = routes[activeRouteIndex];
Â  Â  const steps = route.steps;
Â  Â  const routeDisplayIndex = route.routeIndex; // Get the 0-based index

Â  Â  if (currentStepIndex < steps.length) {
Â  Â  Â  const step = steps[currentStepIndex];
Â  Â  Â  const stepLatLng = L.latLng(step.lat, step.lng);
Â  Â  Â  const distanceToStep = latlng.distanceTo(stepLatLng);

Â  Â  Â  // --- Remaining Distance Calculation (Unchanged) ---
Â  Â  Â  let remainingDistance = distanceToStep; // Start with distance to current step
Â  Â  Â  // Add sum of distances of all subsequent steps
Â  Â  Â  for (let i = currentStepIndex + 1; i < steps.length; i++) {
Â  Â  Â  Â  remainingDistance += steps[i].distance;
Â  Â  Â  }

Â  Â  Â  // Update distance display (routeIndex + 1 for 1-based display)
Â  Â  Â  const distanceEl = document.getElementById(`route-distance-${routeDisplayIndex}`);
Â  Â  Â  if (distanceEl) {
Â  Â  Â  Â  distanceEl.textContent = `${(remainingDistance / 1000).toFixed(1)} km remaining`;
Â  Â  Â  }
Â  Â  Â  // --- END Remaining Distance Calculation ---

Â  Â  Â  // Display upcoming step + distance in tip box (before it's reached)
Â  Â  Â  const upcomingStepDistance = step.distance < 1000 ? `${step.distance.toFixed(0)} m` : `${(step.distance / 1000).toFixed(1)} km`;
Â  Â  Â  document.getElementById("ai-tip").textContent = `Next: ${step.text} (${upcomingStepDistance})`;


Â  Â  Â  // FIX: Only trigger voice + eco update when driver reaches within 50 m AND nextStepReady is true
Â  Â  Â  if (distanceToStep <= 50 && nextStepReady) {
Â  Â  Â  Â  nextStepReady = false; // LOCK: Prevent re-entry

Â  Â  Â  Â  const ecoNow = dynamicEcoAdvisor(currentSpeed, slope, distanceToStep);
Â  Â  Â  Â  eco = ecoNow;
Â  Â  Â  Â  // Determine step distance for speech
Â  Â  Â  Â  const stepDistanceSpeech = step.distance < 1000 ? `${step.distance.toFixed(0)} meters` : `${(step.distance / 1000).toFixed(1)} kilometers`;

Â  Â  Â  Â  // Voice alert (sequential speech)
Â  Â  Â  Â  if ("speechSynthesis" in window) {
Â  Â  Â  Â  Â  // 1. Speak Step Instruction and Distance
Â  Â  Â  Â  Â  const stepMsg = new SpeechSynthesisUtterance(
Â  Â  Â  Â  Â  Â  `${step.text}. Proceed for ${stepDistanceSpeech}.`
Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  stepMsg.rate = 1; stepMsg.pitch = 1;
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // 2. Speak Eco Tip after step instruction
Â  Â  Â  Â  Â  const ecoMsg = new SpeechSynthesisUtterance(
Â  Â  Â  Â  Â  Â  `Eco Tip: Recommended speed ${ecoNow.speed} kilometers per hour, gear ${ecoNow.gear}. ${ecoNow.tip}`
Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  ecoMsg.rate = 1; ecoMsg.pitch = 1;

Â  Â  Â  Â  Â  // Chain the messages
Â  Â  Â  Â  Â  // After step instruction, update tip box to Eco Tip and speak eco tip
Â  Â  Â  Â  Â  stepMsg.onend = () => {
Â  Â  Â  Â  Â  Â  // Stop any previous speech before starting the new one (extra safety)
Â  Â  Â  Â  Â  Â  if (speechSynthesis.speaking) { speechSynthesis.cancel(); }
Â  Â  Â  Â  Â  Â  document.getElementById("ai-tip").textContent = `Tip: ${ecoNow.tip}`;Â 
Â  Â  Â  Â  Â  Â  speechSynthesis.speak(ecoMsg);
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // After eco tip, advance to next step and UNLOCK
Â  Â  Â  Â  Â  ecoMsg.onend = () => {
Â  Â  Â  Â  Â  Â  step.spoken = true;
Â  Â  Â  Â  Â  Â  if (step.element) { step.element.remove(); }
Â  Â  Â  Â  Â  Â  if (step.lineLayer) { route.group.removeLayer(step.lineLayer); }
Â  Â  Â  Â  Â  Â  currentStepIndex++; // Advance step
Â  Â  Â  Â  Â  Â  nextStepReady = true; // UNLOCK
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Start the speech chain and update tip box to Step Instruction
Â  Â  Â  Â  Â  document.getElementById("ai-tip").textContent = `Step ${currentStepIndex + 1}: ${step.text}`;
Â  Â  Â  Â  Â  // Stop any previous speech before starting the new one
Â  Â  Â  Â  Â  if (speechSynthesis.speaking) { speechSynthesis.cancel(); }
Â  Â  Â  Â  Â  speechSynthesis.speak(stepMsg);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Fallback for non-speech browsers: update tip box and advance/unlock immediately
Â  Â  Â  Â  Â  Â  document.getElementById("ai-tip").textContent = `Tip: ${ecoNow.tip}`;
Â  Â  Â  Â  Â  Â  step.spoken = true;
Â  Â  Â  Â  Â  Â  if (step.element) { step.element.remove(); }
Â  Â  Â  Â  Â  Â  if (step.lineLayer) { route.group.removeLayer(step.lineLayer); }
Â  Â  Â  Â  Â  Â  currentStepIndex++;
Â  Â  Â  Â  Â  Â  nextStepReady = true;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  // Route finished
Â  Â  Â  document.getElementById("ai-tip").textContent = "Destination reached âœ…";
Â  Â  Â  // Clear distance display for finished route
Â  Â  Â  const distanceEl = document.getElementById(`route-distance-${route.routeIndex}`);
Â  Â  Â  if (distanceEl) {
Â  Â  Â  Â  distanceEl.textContent = `0.0 km remaining`;
Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  if ("speechSynthesis" in window)
Â  Â  Â  Â  speechSynthesis.speak(new SpeechSynthesisUtterance("Destination reached"));
Â  Â  Â  activeRouteIndex = null;
Â  Â  Â  currentStepIndex = 0;
Â  Â  Â  nextStepReady = true;
Â  Â  }
Â  }

Â  // Apply dynamic eco hints even without route
Â  updateDriverBehavior(currentSpeed, eco);

Â  // Dashboard updates
Â  document.getElementById("speed").textContent = eco.speed + " km/h";
Â  document.getElementById("gear").textContent = eco.gear;
Â  document.getElementById("throttle").textContent = eco.throttle + "%";
}
/* ===== GPS speed and idle detection (Unchanged) ===== */
let lastLatLng=null, lastGPSPos=null, lastGPSTime=null, idleStart=null;
const IDLE_THRESHOLD=3, IDLE_TIME=60;
function checkIdle(latlng){
Â  Â  if(!lastLatLng){ lastLatLng=latlng; idleStart=Date.now(); return false; }
Â  Â  const dist=latlng.distanceTo(lastLatLng);
Â  Â  if(dist<IDLE_THRESHOLD){ if(!idleStart) idleStart=Date.now(); return (Date.now()-idleStart)/1000 >= IDLE_TIME; }
Â  Â  lastLatLng=latlng; idleStart=null; return false;
}

function calculateGPSSpeed(latlng){
Â  Â  const now=Date.now();
Â  Â  if(lastGPSPos && lastGPSTime){
Â  Â  Â  Â  const dist=latlng.distanceTo(lastGPSPos);
Â  Â  Â  Â  const dt=(now-lastGPSTime)/1000;
Â  Â  Â  Â  lastGPSPos=latlng; lastGPSTime=now;
Â  Â  Â  Â  return (dist/dt)*3.6;
Â  Â  }else{ lastGPSPos=latlng; lastGPSTime=now; return 0; }
}

/* ===== Predict multi-step elevation ahead (Unchanged) ===== */
const ELEVATION_INTERVAL=50;Â 
const LOOKAHEAD_DISTANCE=400;Â 
let recentElevations=[];
async function predictElevationAhead(latlng,heading){
Â  Â  const R=6378137;Â 
Â  Â  const pointsAhead=[];
Â  Â  for(let d=ELEVATION_INTERVAL; d<=LOOKAHEAD_DISTANCE; d+=ELEVATION_INTERVAL){
Â  Â  Â  Â  const latRad=latlng.lat*Math.PI/180, lonRad=latlng.lng*Math.PI/180;
Â  Â  Â  Â  const newLat=latRad+(d*Math.cos(heading*Math.PI/180))/R;
Â  Â  Â  Â  const newLng=lonRad+(d*Math.sin(heading*Math.PI/180))/(R*Math.cos(latRad));
Â  Â  Â  Â  pointsAhead.push({lat:newLat*180/Math.PI,lng:newLng*180/Math.PI});
Â  Â  }
Â  Â  const elevs=await getElevations(pointsAhead);
Â  Â  recentElevations=elevs;
Â  Â  const diffs=elevs.map((v,i)=>i===0?0:v-elevs[i-1]);
Â  Â  const avgSlope=diffs.reduce((a,b)=>a+b,0)/diffs.length;
Â  Â  return {elevs, slope:avgSlope};
}

/* ===== GPS Watch (Unchanged) ===== */
if(navigator.geolocation){
Â  Â  navigator.geolocation.watchPosition(async pos=>{
Â  Â  Â  Â  const latlng=L.latLng(pos.coords.latitude,pos.coords.longitude);
Â  Â  Â  Â  const heading=pos.coords.heading||0;
Â  Â  Â  Â  if(!waypoints.length) waypoints.push(latlng); else waypoints[0]=latlng;
Â  Â  Â  Â  if(!userMarker){ userMarker=L.marker(latlng,{icon:carIcon}).addTo(map); map.setView(latlng,14); }
Â  Â  Â  Â  else userMarker.setLatLng(latlng);
Â  Â  Â  Â  await adaptiveAIDashboard(latlng,heading);
Â  Â  Â  Â  checkOffRoute(latlng);
Â  Â  },()=>console.warn("GPS unavailable"),{enableHighAccuracy:true});
}

/* ===== Off-route adaptation (Unchanged) ===== */
async function checkOffRoute(latlng){
Â  Â  if(routes.length){
Â  Â  Â  Â  const nearestRoute=routes[0];
Â  Â  Â  Â  let minDist=Infinity;
Â  Â  Â  Â  nearestRoute.steps.forEach(s=>{ const d=latlng.distanceTo([s.lat,s.lng]); if(d<minDist) minDist=d; });
Â  Â  Â  Â  if(minDist>30){
Â  Â  Â  Â  Â  Â  console.log("Off-route detected â€” recalculating");
Â  Â  Â  Â  Â  Â  if(waypoints.length>=1){
Â  Â  Â  Â  Â  Â  Â  Â  const lastWaypoint=waypoints[waypoints.length-1];
Â  Â  Â  Â  Â  Â  Â  Â  createRoute(latlng,lastWaypoint,colors[routes.length%colors.length]);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
}

/* ===== Route creation & step-box integration (Unchanged logic) ===== */
async function createRoute(start, end, color, marker = null, index = null) {
Â  Â  // Determine the 0-based index for the internal array and 1-based index for display/ID
Â  Â  const routeIndex = index !== null ? index : routes.length;Â 
Â  Â  const displayIndex = index !== null ? index : routes.length + 1;Â 

Â  Â  // Check for duplicate destination
Â  Â  const endKey = `${end.lat.toFixed(6)},${end.lng.toFixed(6)}`;
Â  Â  const existing = routes.find(r => r.endKey === endKey);
Â  Â  if (existing) return; // Skip creating duplicate route box
Â  Â  const routeColor = color || colors[(routeIndex) % colors.length];

Â  Â  const rc = L.Routing.control({
Â  Â  Â  Â  waypoints: [start, end],
Â  Â  Â  Â  router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' }),
Â  Â  Â  Â  show: false, addWaypoints: false, createMarker: () => null,
Â  Â  Â  Â  lineOptions: { styles: [{ color: routeColor, weight: 5, opacity: 0.9 }] }
Â  Â  }).addTo(map);
Â  Â  const group = L.layerGroup().addTo(map);

Â  Â  // Route box
Â  Â  const box = document.createElement('div'); box.className = 'route-box';
Â  Â  const header = document.createElement('div'); header.className = 'route-header';
Â  Â  header.style.background = routeColor;
Â  Â  // --- NEW: Include a span for total distance in the header with the routeIndex as ID ---
Â  Â  header.innerHTML = `<b>Route ${displayIndex}</b> <span id="route-distance-${routeIndex}" style="font-weight:normal;">Calculating...</span>
Â  Â  Â  Â  <button style="background:#ff4c4c;border:none;color:#fff;border-radius:50%;width:22px;height:22px;">âœ•</button>`;
Â  Â  // --- END NEW ---
Â  Â  const content = document.createElement('div'); content.className = 'route-content';
Â  Â  content.style.display = 'block'; box.appendChild(header); box.appendChild(content);
Â  Â  document.getElementById('routePanel').appendChild(box);
Â  Â  header.onclick = () => content.style.display = content.style.display === 'block' ? 'none' : 'block';
Â  Â  header.querySelector('button').onclick = (e) => {
Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  map.removeControl(rc); map.removeLayer(group); box.remove();
Â  Â  Â  Â  const idx = routes.findIndex(r => r.rc === rc);Â 
Â  Â  Â  Â  if (idx !== -1) {
Â  Â  Â  Â  Â  Â  // If active route deleted, reset tip box
Â  Â  Â  Â  Â  Â  if (activeRouteIndex === idx) {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('ai-tip').textContent = 'Drive smoothly';
Â  Â  Â  Â  Â  Â  Â  Â  activeRouteIndex = null;
Â  Â  Â  Â  Â  Â  Â  Â  currentStepIndex = 0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  routes.splice(idx, 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (marker) {
Â  Â  Â  Â  Â  Â  const wpIdx = waypointMarkers.indexOf(marker);Â Â 
Â  Â  Â  Â  Â  Â  if (wpIdx !== -1) { map.removeLayer(marker); waypointMarkers.splice(wpIdx, 1); waypoints.splice(wpIdx + 1, 1); }
Â  Â  Â  Â  }
Â  Â  Â  Â  rebuildRoutes();
Â  Â  };

Â  Â  rc.on('routesfound', async e => {
Â  Â  Â  Â  const route = e.routes[0];
Â  Â  Â  Â  const coords = route.coordinates.map(c => ({ lat: c.lat, lng: c.lng }));
Â  Â  Â  Â  const elevs = await getElevations(coords);
Â  Â  Â  Â  const steps = [];
Â  Â  Â  Â  content.innerHTML = '';
Â  Â  Â  Â  route.instructions.forEach((s, j) => {
Â  Â  Â  Â  Â  Â  const idxStart = s.index;
Â  Â  Â  Â  Â  Â  const idxEnd = j + 1 < route.instructions.length ? route.instructions[j + 1].index : coords.length;
Â  Â  Â  Â  Â  Â  const segmentCoords = coords.slice(idxStart, idxEnd).map(c => [c.lat, c.lng]);
Â  Â  Â  Â  Â  Â  const elev = elevs[idxStart] || 0;
Â  Â  Â  Â  Â  Â  const stepLine = L.polyline(segmentCoords, { color: routeColor, weight: 5, opacity: 0.5 }).addTo(group);
Â  Â  Â  Â  Â  Â  const eco = ecoAdvisor(s.distance, elev, s.text);
Â  Â  Â  Â  Â  Â  const item = document.createElement('div');
Â  Â  Â  Â  Â  Â  item.className = 'route-step';
Â  Â  Â  Â  Â  Â  item.innerHTML = `<b>${s.text}</b><div>${(s.distance / 1000).toFixed(2)} km | Elev ${elev.toFixed(1)} m`;
Â  Â  Â  Â  Â  Â  content.appendChild(item);
Â  Â  Â  Â  Â  Â  item.addEventListener('mouseenter', () => stepLine.setStyle({ color: '#00FF00', weight: 6, opacity: 0.9 }));
Â  Â  Â  Â  Â  Â  item.addEventListener('mouseleave', () => stepLine.setStyle({ color: routeColor, weight: 5, opacity: 0.5 }));
Â  Â  Â  Â  Â  Â  // --- UPDATED: Store distance, element, and lineLayer ---
Â  Â  Â  Â  Â  Â  steps.push({Â 
Â  Â  Â  Â  Â  Â  Â  Â  lat: coords[idxStart].lat,Â 
Â  Â  Â  Â  Â  Â  Â  Â  lng: coords[idxStart].lng,Â 
Â  Â  Â  Â  Â  Â  Â  Â  text: s.text,Â 
Â  Â  Â  Â  Â  Â  Â  Â  elev,Â 
Â  Â  Â  Â  Â  Â  Â  Â  element: item, // DOM element for removal
Â  Â  Â  Â  Â  Â  Â  Â  distance: s.distance, // Distance for remaining distance calc
Â  Â  Â  Â  Â  Â  Â  Â  lineLayer: stepLine // Leaflet layer for removal
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  // --- END UPDATED ---
Â  Â  Â  Â  });
Â  Â  Â  Â  // --- NEW: Store total distance and index, and update initial display ---
Â  Â  Â  Â  const totalRouteDistance = route.summary.totalDistance;
Â  Â  Â  Â  routes.push({ rc, group, steps, color: routeColor, endKey, totalDistance: totalRouteDistance, routeIndex: routeIndex });
Â  Â  Â  Â  document.getElementById(`route-distance-${routeIndex}`).textContent = `${(totalRouteDistance / 1000).toFixed(1)} km total`;
Â  Â  Â  Â  // --- END NEW ---

Â  Â  Â  Â  // Only set as active route if no other route is in progress
Â  Â  Â  Â  if (activeRouteIndex === null) {
Â  Â  Â  Â  Â  Â  activeRouteIndex = routeIndex;
Â  Â  Â  Â  Â  Â  currentStepIndex = 0;
Â  Â  Â  Â  Â  Â  speakCurrentStep(); // Speak the first step immediately
Â  Â  Â  Â  }
Â  Â  });
}


/*================Multi-step AI Tip Blending + Voice (FIXED)=============*/
function speakCurrentStep() {
Â  if (activeRouteIndex === null) return;
Â  const route = routes[activeRouteIndex];
Â  const step = route.steps[0];
Â  if (!step || step.spoken) return;

Â  const eco = ecoAdvisor(step.distance, step.elev, step.text);
Â  const stepDistance = step.distance < 1000 ? `${step.distance.toFixed(0)} meters` : `${(step.distance / 1000).toFixed(1)} kilometers`;

Â  // 1. Speak Step Instruction and Distance
Â  const stepMsg = new SpeechSynthesisUtterance(
Â  Â  `Starting route. Step 1: ${step.text}. Proceed for ${stepDistance}`
Â  );
Â  stepMsg.rate = 1; stepMsg.pitch = 1;
Â Â 
Â  // 2. Speak Eco Tip after step instruction
Â  const ecoMsg = new SpeechSynthesisUtterance(
Â  Â  `Eco Tip: ${eco.tip}`
Â  );
Â  ecoMsg.rate = 1; ecoMsg.pitch = 1;

Â  if ("speechSynthesis" in window) {
Â  Â  // Chain the messages
Â  Â  stepMsg.onend = () => {
Â  Â  Â  // Update tip box to Eco Tip after step instruction finishes
Â  Â  Â  document.getElementById("ai-tip").textContent = `Tip: ${eco.tip}`;Â 
Â  Â  Â  speechSynthesis.speak(ecoMsg);
Â  Â  };
Â  Â Â 
Â  Â  ecoMsg.onend = () => {
Â  Â  Â  step.spoken = true;
Â  Â  };

Â  Â  // Start the speech chain and update tip box to Step Instruction
Â  Â  document.getElementById("ai-tip").textContent = `Step 1: ${step.text}`;Â 
Â  Â  if (speechSynthesis.speaking) { speechSynthesis.cancel(); } // Ensure no old messages interfere
Â  Â  speechSynthesis.speak(stepMsg);
Â  } else {
Â  Â  document.getElementById("ai-tip").textContent = `Tip: ${eco.tip}`;
Â  Â  step.spoken = true;
Â  }
}

/* ===== Add waypoint on map click (Unchanged) ===== */
map.on('click',e=>{
Â  Â  const latlng=e.latlng; waypoints.push(latlng);
Â  Â  const marker=L.marker(latlng).addTo(map); waypointMarkers.push(marker);
Â  Â  if(waypoints.length>=2) createRoute(waypoints[waypoints.length-2],latlng,colors[routes.length%colors.length],marker);
});

/* ===== Rebuild Routes (Unchanged) ===== */
function rebuildRoutes(){
Â  Â  routes.forEach(r=>{ map.removeControl(r.rc); map.removeLayer(r.group); });
Â  Â  routes=[]; document.getElementById('routePanel').innerHTML='';
Â  Â  if(waypoints.length<2) return;
Â  Â  for(let i=1;i<waypoints.length;i++){ createRoute(waypoints[i-1],waypoints[i],colors[(i-1)%colors.length],waypointMarkers[i-1],i); }
}


/* ===== Map Toggle (MODIFIED to remove camera reference) ===== */
let mapFull=false;
document.getElementById("map-toggle").addEventListener("click",()=>{
Â  const mapContainer=document.querySelector(".map-container");
Â  const button=document.getElementById("map-toggle");
Â  if(!mapFull){
Â  Â  mapContainer.style.position="fixed"; mapContainer.style.top="0"; mapContainer.style.left="0"; mapContainer.style.width="100vw"; mapContainer.style.height="100vh"; mapContainer.style.zIndex="2000";
Â  Â  button.innerText="Restore Map"; mapFull=true; setTimeout(()=>map.invalidateSize(),300);
Â  }else{
Â  Â  mapContainer.style.position=""; mapContainer.style.width=""; mapContainer.style.height=""; mapContainer.style.zIndex="";
Â  Â  button.innerText="Full Map"; mapFull=false; setTimeout(()=>map.invalidateSize(),300);
Â  }
});

/* ===== Camera Toggle (REMOVED) ===== */

/* ===== Search Suggestions (Unchanged) ===== */
const input=document.getElementById('searchInput');
const suggestBox=document.getElementById('suggestBox');
let results=[];
input.oninput=async()=>{
Â  const q=input.value.trim();
Â  if(!q){suggestBox.style.display='none';return;}
Â  const d=await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&limit=12`)
Â  Â  Â .then(r=>r.json()).catch(()=>({features:[]}));
Â  results=d.features||[];
Â  suggestBox.innerHTML='';
Â  results.forEach((f,i)=>{
Â  Â  const p=f.properties||{},name=p.name||p.city||'Unknown';
Â  Â  const info=[p.state,p.country].filter(Boolean).join(', ');
Â  Â  const div=document.createElement('div');
Â  Â  div.className='suggest-item';
Â  Â  div.innerHTML=`<b>${name}</b><div style="font-size:12px;color:#bbb;">${info}</div>`;
Â  Â  div.onclick=()=>selectResult(i);
Â  Â  suggestBox.appendChild(div);
Â  });
Â  suggestBox.style.display=results.length?'block':'none';
};
document.addEventListener('click',e=>{
Â  if(!suggestBox.contains(e.target)&&e.target!==input)suggestBox.style.display='none';
});
function selectResult(i){
Â  const f=results[i]; if(!f)return;
Â  const [lng,lat]=f.geometry.coordinates; const latlng=L.latLng(lat,lng);
Â  waypoints.push(latlng);
Â  const marker=L.marker(latlng).addTo(map);
Â  waypointMarkers.push(marker);
Â  if(waypoints.length>=2) createRoute(waypoints[waypoints.length-2],latlng,colors[routes.length%colors.length]);
Â  input.value=''; suggestBox.style.display='none';
}

/* ===== Voice Search (Mic Button) (Unchanged) ===== */
const micBtn = document.getElementById('micBtn');

micBtn.onclick = async () => {
Â  if (!('webkitSpeechRecognition' in window)) {
Â  Â  alert('Speech Recognition not supported on this browser');
Â  Â  return;
Â  }

Â  try {
Â  Â  // âœ… Ask for microphone permission explicitly (like location)
Â  Â  await navigator.mediaDevices.getUserMedia({ audio: true });

Â  Â  const recog = new webkitSpeechRecognition();
Â  Â  recog.lang = 'en-US';
Â  Â  recog.interimResults = false;
Â  Â  recog.maxAlternatives = 1;

Â  Â  micBtn.textContent = 'ðŸŽ™ï¸ Listening...';
Â  Â  recog.start();

Â  Â  recog.onresult = (e) => {
Â  Â  Â  const text = e.results[0][0].transcript;
Â  Â  Â  input.value = text;
Â  Â  Â  input.dispatchEvent(new Event('input'));
Â  Â  };

Â  Â  recog.onerror = (err) => {
Â  Â  Â  console.warn('Speech recognition error:', err);
Â  Â  Â  micBtn.textContent = 'ðŸŽ¤';
Â  Â  };

Â  Â  recog.onend = () => {
Â  Â  Â  micBtn.textContent = 'ðŸŽ¤';
Â  Â  };

Â  } catch (err) {
Â  Â  // ðŸš« Permission denied or mic unavailable
Â  Â  console.error('Microphone access denied:', err);
Â  Â  alert('Please allow microphone permission to use voice search.');
Â  }
};

</script>
</body>
</html>
