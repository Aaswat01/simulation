<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Eco Driving Dashboard Simulation</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
<style>
/* Reset and Base Styles */
*{box-sizing:border-box;margin:0;padding:0;}
body{background:radial-gradient(circle at top left,#0f1c2e,#1c2b44,#2a3b60);font-family:"Segoe UI",Arial,sans-serif;color:#fff;height:100vh;display:flex;flex-direction:column;overflow:hidden;}

/* === HEADER === */
.ai-tip-box{flex:0 0 auto;background:#ffa500;color:#000;border-radius:1vh;
margin:1vh 2vw;padding:1.5vh 1vw;text-align:center;font-weight:bold;
font-size:clamp(1rem,2vw,1.6rem);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.stats-row{display:flex;justify-content:space-evenly;align-items:stretch;
flex-wrap:wrap;gap:1vh;margin:0 1vw;}
.stat-card{flex:1;min-width:120px;max-width:180px;background:rgba(28,34,48,0.95);
border-radius:1vh;padding:1vh;display:flex;flex-direction:column;justify-content:center;
align-items:center;text-align:center;border:1px solid rgba(255,255,255,0.2);
box-shadow:0 0.3vh 1vh rgba(0,0,0,0.4);}
.stat-label{font-size:0.9rem;opacity:0.8;}
.stat-value{font-size:1.3rem;font-weight:bold;margin-top:0.3rem;}
.speed-box{background:#4e79a7;}
.gear-box{background:#76b7b2;color:#000;}
.throttle-box{background:#2ca02c;color:#000;}

/* === SEARCH === */
.search-row{display:flex;align-items:center;justify-content:center;gap:1vw;margin:1vh 2vw;position:relative;}
#searchInput{flex:1;max-width:70%;padding:0.8vh 1vw;font-size:1rem;border-radius:1vh;
border:none;outline:none;}
#micBtn{background:#ff4c4c;color:#fff;border:none;border-radius:1vh;padding:0.8vh 1.2vw;
font-weight:bold;cursor:pointer;box-shadow:0 0.4vh 1vh rgba(0,0,0,0.3);}
#suggestBox{position:absolute;top:100%;left:10%;width:80%;background:rgba(0,0,0,0.9);
border-radius:1vh;max-height:40vh;overflow-y:auto;z-index:2000;display:none;}
.suggest-item{padding:0.8vh 1vw;border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer;}
.suggest-item:hover{background:rgba(255,255,255,0.1);}

/* === MAIN === */
.main-section{flex:1;display:flex;flex-direction:column;gap:1vh;padding:0 2vw 1vh;}
.map-container{flex:1;position:relative;border-radius:1vh;overflow:hidden;
border:1px solid rgba(255,255,255,0.2);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.map{width:100%;height:100%;}
#map-toggle{position:absolute;top:1vh;right:1vh;z-index:1000;background:#ff8c00;
border:none;border-radius:1vh;padding:0.5vh 1vw;font-weight:bold;cursor:pointer;color:#000;}

/* === ROUTE PANEL (Improved UI) === */
#routePanel{
position:absolute;bottom:2vh;left:2vw;width:300px;max-height:90%;
overflow-y:auto;background:rgba(0,0,0,0.7);border-radius:1vh;
padding:10px;color:#fff;z-index:999;box-shadow:0 0 20px rgba(0,0,0,0.5);
}
.route-box{
margin-bottom:1.5vh;border-radius:1vh;overflow:hidden;
background:rgba(255,255,255,0.08);backdrop-filter:blur(5px);
box-shadow:0 0.4vh 1vh rgba(0,0,0,0.5);
border:1px solid rgba(255,255,255,0.1);
}
.route-header{
padding:0.8vh 1vw;font-weight:bold;display:flex;justify-content:space-between;
align-items:center;color:#fff;font-size:1rem;cursor:pointer;
border-bottom:1px solid rgba(255,255,255,0.2);
}
.route-header button{
background:#ff4c4c;border:none;color:#fff;border-radius:50%;
width:24px;height:24px;font-size:14px;cursor:pointer;
}
.route-content{
background:rgba(0,0,0,0.4);padding:0.5vh 1vw;font-size:0.9rem;
max-height:30vh;overflow-y:auto;transition:all 0.3s ease;
}
.route-step{
padding:0.6vh 0;margin-bottom:0.4vh;
border-bottom:1px solid rgba(255,255,255,0.1);
}
.route-step:last-child { border-bottom: none; }
.route-step:hover{background:rgba(255,255,255,0.05);}
.route-distance-info {
padding: 0.5vh 1vw;
font-size: 0.9rem;
font-style: italic;
background: rgba(255, 255, 255, 0.1);
}
/* REMOVE CAMERA BOX CSS */
.camera{ display: none !important; }
</style>
</head>
<body>
<div class="ai-tip-box" id="ai-tip">Drive smoothly</div>
<div class="stats-row">
Â  <div class="stat-card speed-box"><div class="stat-label">Speed</div><div class="stat-value" id="speed">0 km/h</div></div>
Â  <div class="stat-card gear-box"><div class="stat-label">Gear</div><div class="stat-value" id="gear">N</div></div>
Â  <div class="stat-card throttle-box"><div class="stat-label">Throttle</div><div class="stat-value" id="throttle">0%</div></div>
</div>

<div class="search-row">
Â  <input type="text" id="searchInput" placeholder="Search destination (e.g., Mumbai, Paris, London)...">
Â  <button id="micBtn">ðŸŽ¤</button>
Â  <div id="suggestBox"></div>
</div>

<div class="main-section">
Â  <div class="map-container">
Â  Â  <div id="map" class="map"></div>
Â  Â  <button id="map-toggle">Full Map</button>
Â  Â  <div id="routePanel"></div>
Â  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script>
/* ===== Map Init ===== */
const map=L.map('map').setView([24.7136,46.6753],13); // Default to Riyadh, Saudi Arabia
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'Â© OSM'}).addTo(map);
const carIcon=L.icon({iconUrl:'https://cdn-icons-png.flaticon.com/512/3097/3097144.png',iconSize:[42,42]});
let userMarker=null,waypoints=[],waypointMarkers=[],routes=[],totalFuel=0;
const colors=['#FF6B6B','#4DA6FF','#FFD93D','#6BCB77','#FF8C00','#9B59B6','#00BFA5'];

/* Global Simulation Variables */
let simulationInterval = null; // Holds the setInterval for car movement
let currentSimulatedSpeed = 0; // Tracks the car's current speed in the simulation
let simCoords = []; // The full set of coordinates for the active route
let simIndex = 0; // Current index in simCoords
let nextStepReady = true; // Prevents overlapping voice prompts
let stepArrivalPending = false; // Manages the brief tip takeover for instructions

/* ===== Eco Advisor (Unchanged from original logic) ===== */
function ecoAdvisor(dist,elev,turnText){
Â  Â  const t=(turnText||'').toLowerCase();
Â  Â  let tip="Drive smoothly", speed=50, gear=3, throttle=45;

Â  Â  // Road type detection
Â  Â  const roadType=t.includes("highway")?"highway":
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â t.includes("city")?"city":
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â t.includes("roundabout")?"roundabout":"normal";

Â  Â  if(t.includes("left")||t.includes("right")) { speed=25; gear=2; throttle=35; tip="Slow for turn"; }
Â  Â  else if(elev>6) { speed=30; gear=2; throttle=55; tip="Uphill â€” maintain torque"; }
Â  Â  else if(elev<-6){ speed=55; gear=5; throttle=25; tip="Downhill â€” coast gently"; }
Â  Â  else if(dist>800){ speed=65; gear=5; throttle=50; tip="Long straight â€” steady speed"; }
Â  Â  else if(dist>300){ speed=55; gear=4; throttle=45; tip="Smooth cruising"; }

Â  Â  // Adjustments by road type
Â  Â  if(roadType==="highway"){ speed=Math.min(speed,80); gear=Math.max(gear,5); throttle=50; tip+=" â€” highway"; }
Â  Â  else if(roadType==="city"){ speed=Math.min(speed,50); gear=Math.min(gear,3); throttle=40; tip+=" â€” city"; }
Â  Â  else if(roadType==="roundabout"){ speed=25; gear=2; throttle=35; tip+=" â€” roundabout"; }

Â  Â  // Fuel saving hints
Â  Â  if(speed>70) tip="High speed â€” reduce for fuel saving";
Â  Â  if(throttle>60 && elev>3) tip="High throttle uphill â€” shift earlier";

Â  Â  return {speed, gear, throttle, tip};
}

/* ===== Dynamic Eco Advisor (For smooth transition tips) - Simplified for dashboard feedback ===== */
function dynamicEcoAdvisor(currentSpeed, slopeAhead, distToNextStep){
Â  Â  let tip = "Smooth cruising", speed = 50, gear = 4, throttle = 45;

Â  Â  if(distToNextStep < 100){ speed = Math.max(currentSpeed * 0.7, 20); tip = "Approaching turn â€” slow down"; gear = 2; }
Â  Â  else if(slopeAhead > 5){ speed = Math.min(currentSpeed + 10, 70); throttle = 55; tip = "Uphill: Maintain momentum"; gear = 4; }
Â  Â  else if(slopeAhead < -5){ speed = Math.max(currentSpeed - 10, 25); throttle = 25; tip = "Downhill: Coast & control speed"; gear = 3; }
Â  Â  else if(distToNextStep > 1000) { speed = 65; tip = "Long stretch â€” maintain 65 km/h"; gear = 5; }
Â  Â  else { speed = 50; tip = "Smooth cruising"; gear = 4; }

Â  Â  // Ensure speed is reasonable
Â  Â  speed = Math.max(20, Math.min(80, speed));
Â  Â  throttle = Math.max(20, Math.min(60, throttle));

Â  Â  return {speed, gear, throttle, tip};
}

/* ===== Driver Behavior Monitoring (Modified for spoken warnings) ===== */
let driverStats = { overspeed: 0, harshAccel: 0, totalPoints: 0 };
let spokenWarnings = new Set();Â 

function updateDriverBehavior(currentSpeed, eco) {
Â  Â  // NOTE: Eco speed is now the TARGET speed. We use the *currentSimulatedSpeed* for behavior.
Â  Â  driverStats.totalPoints++;
Â  Â  let warnings = [];

Â  Â  // Overspeed detection: Check if the *simulated* speed is > the AI target speed + 5 km/h
Â  Â  if (currentSpeed > eco.speed + 5) {
Â  Â  Â  Â  driverStats.overspeed++;
Â  Â  Â  Â  // Only speak the warning once until the driver corrects, or periodically
Â  Â  Â  Â  if (!spokenWarnings.has('overspeed')) {
Â  Â  Â  Â  Â  Â  // REMOVED the intrusive, repeating voice command for overspeeding as requested
Â  Â  Â  Â  Â  Â  warnings.push(`Overspeeding: Target ${eco.speed} km/h.`);
Â  Â  Â  Â  Â  Â  spokenWarnings.add('overspeed');
Â  Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  Â  spokenWarnings.delete('overspeed'); // Clear warning when back to normal
Â  Â  }

Â  Â  // Harsh acceleration detection
Â  Â  const lastThrottle = parseFloat(document.getElementById("throttle").dataset.lastThrottle || 0);
Â  Â  const currentThrottle = eco.throttle;
Â  Â  if (Math.abs(currentThrottle - lastThrottle) > 25 && Math.random() < 0.1) {Â 
Â  Â  Â  Â  driverStats.harshAccel++;
Â  Â  Â  Â  if (!spokenWarnings.has('harshAccel')) {
Â  Â  Â  Â  Â  Â  warnings.push("Harsh acceleration detected â€” Smooth throttle input!");
Â  Â  Â  Â  Â  Â  spokenWarnings.add('harshAccel');
Â  Â  Â  Â  Â  Â  setTimeout(() => spokenWarnings.delete('harshAccel'), 5000); // Clear after 5s
Â  Â  Â  Â  }
Â  Â  }
Â  Â  document.getElementById("throttle").dataset.lastThrottle = currentThrottle;

Â  Â  // Voice alert (Speak only one warning at a time, prioritize the first one)
Â  Â  if ('speechSynthesis' in window && warnings.length) {
Â  Â  Â  Â  if(speechSynthesis.speaking) return;Â 
Â  Â  Â  Â  const msg = new SpeechSynthesisUtterance(warnings[0]);
Â  Â  Â  Â  msg.rate = 1; msg.pitch = 1;
Â  Â  Â  Â  // Don't speak overspeeding warning repeatedly, but show the tip.
Â  Â  Â  Â  if (!warnings[0].includes("Overspeeding")) {
Â  Â  Â  Â  Â  Â  speechSynthesis.speak(msg);
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  return warnings.length > 0 ? warnings[0] : null; // Return the active warning tip
}

/* ===== GPS & Elevation Stubs (Unchanged/Simplified) ===== */
function calculateGPSSpeed(latlng){ return currentSimulatedSpeed; }
async function getElevations(coords){
Â  Â  const fakeElevs = coords.map((c, i) =>Â 
Â  Â  Â  Â  Math.sin(c.lat * 100 + c.lng * 100 + i * 0.1) * 20 +
Â  Â  Â  Â  Math.sin(i * 0.05) * 50 + 10
Â  Â  );
Â  Â  return fakeElevs;
}
async function predictElevationAhead(latlng,heading){
Â  Â  return {elevs: [], slope: 3}; // Default to slight uphill
}

/* ====== Step-by-Step AI Voice Guidance & Dashboard Update (Refined) ====== */
let activeRouteIndex = null;
let currentStepIndex = 0;

async function adaptiveAIDashboard(latlng, heading) {
Â  Â  const slopeData = await predictElevationAhead(latlng, heading);
Â  Â  const slope = slopeData.slope;
Â  Â  let aiTipText = "Drive smoothly"; // Default tip

Â  Â  // --- Calculate Base Eco Advice ---
Â  Â  // Use a simplified version of ecoAdvisor to get the general recommendation
Â  Â  let baseEco = ecoAdvisor(1000, slope, "normal"); // Assume long, normal road for base
Â  Â  let eco = baseEco; // Start with base eco

Â  Â  if (routes.length && activeRouteIndex !== null) {
Â  Â  Â  Â  const route = routes[activeRouteIndex];
Â  Â  Â  Â  const steps = route.steps;
Â  Â  Â  Â  const endLatLng = route.endLatLng;Â 

Â  Â  Â  Â  // Dynamic distance to destination update (Overall distance reduction)
Â  Â  Â  Â  const distanceToDest = latlng.distanceTo(endLatLng);
Â  Â  Â  Â  const distanceElement = route.box.querySelector('#distanceToDest');
Â  Â  Â  Â  if (distanceElement) {
Â  Â  Â  Â  Â  Â  distanceElement.innerHTML = `<b>Distance to Destination: ${(distanceToDest / 1000).toFixed(2)} km</b>`;
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Step Removal Logic ---
Â  Â  Â  Â  if (steps.length > 0) {
Â  Â  Â  Â  Â  Â  const step = steps[0];
Â  Â  Â  Â  Â  Â  const stepLatLng = L.latLng(step.lat, step.lng);
Â  Â  Â  Â  Â  Â  const distanceToStepMeters = latlng.distanceTo(stepLatLng);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Use the step's original distance for display, but dynamic distance for advice
Â  Â  Â  Â  Â  Â  const stepOriginalDistanceText = step.originalDistanceText; // This is the fixed, original distance from route calc

Â  Â  Â  Â  Â  Â  // Dynamic eco advice based on step distance and simulated slope
Â  Â  Â  Â  Â  Â  const ecoNow = dynamicEcoAdvisor(currentSimulatedSpeed, slope, distanceToStepMeters);
Â  Â  Â  Â  Â  Â  eco = ecoNow; // Use dynamic eco advice for dashboard stats

Â  Â  Â  Â  Â  Â  // --- Tip Box Logic (Priority: Warning > Step > Eco Tip) ---
Â  Â  Â  Â  Â  Â  if (stepArrivalPending) {
Â  Â  Â  Â  Â  Â  Â  Â  // Show step instruction during the brief announcement period
Â  Â  Â  Â  Â  Â  Â  Â  aiTipText = `TURN AHEAD: ${step.text} (${stepOriginalDistanceText} total distance)`;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  // Continuous tip update: Base Eco Tip + Next Step info
Â  Â  Â  Â  Â  Â  Â  Â  aiTipText = `${ecoNow.tip} â€” Next: ${step.text} (${distanceToStepMeters.toFixed(0)} meters ahead)`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Check for driver behavior warnings (overrides eco/step text)
Â  Â  Â  Â  Â  Â  const driverWarning = updateDriverBehavior(currentSimulatedSpeed, eco);
Â  Â  Â  Â  Â  Â  if (driverWarning) aiTipText = driverWarning;

Â  Â  Â  Â  Â  Â  // Trigger voice guidance and step completion when very close (100m)
Â  Â  Â  Â  Â  Â  if (distanceToStepMeters <= 100 && nextStepReady) { // Increased trigger distance
Â  Â  Â  Â  Â  Â  Â  Â  nextStepReady = false;
Â  Â  Â  Â  Â  Â  Â  Â  stepArrivalPending = true; // Flag for tip box change

Â  Â  Â  Â  Â  Â  Â  Â  // Speak step instructionÂ 
Â  Â  Â  Â  Â  Â  Â  Â  if ("speechSynthesis" in window) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (speechSynthesis.speaking) speechSynthesis.cancel();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const msg = new SpeechSynthesisUtterance(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `${step.text}. Now. Follow ${ecoNow.tip}`
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  msg.rate = 1.1; msg.pitch = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speechSynthesis.speak(msg);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Remove step line and box element after a fixed delay
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(step.line) route.group.removeLayer(step.line);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(step.element) step.element.remove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  route.steps.shift(); // Advance to next step
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextStepReady = true; // Ready for the next prompt
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stepArrivalPending = false; // Restore normal tip
Â  Â  Â  Â  Â  Â  Â  Â  }, 3000); // 3 second delay for instruction to finish
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Route finished
Â  Â  Â  Â  Â  Â  if(simulationInterval !== null) clearInterval(simulationInterval);
Â  Â  Â  Â  Â  Â  aiTipText = "Destination reached âœ…";
Â  Â  Â  Â  Â  Â  if ("speechSynthesis" in window && !speechSynthesis.speaking)
Â  Â  Â  Â  Â  Â  Â  Â  speechSynthesis.speak(new SpeechSynthesisUtterance("Destination reached"));
Â  Â  Â  Â  Â  Â  activeRouteIndex = null;
Â  Â  Â  Â  Â  Â  nextStepReady = true;
Â  Â  Â  Â  Â  Â  stepArrivalPending = false;

Â  Â  Â  Â  Â  Â  // Auto-remove finished route box after delay
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  const routeIndexToRemove = routes.findIndex(r => r.rc === route.rc);
Â  Â  Â  Â  Â  Â  Â  Â  if (routeIndexToRemove !== -1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  map.removeControl(route.rc); map.removeLayer(route.group); route.box.remove();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  routes.splice(routeIndexToRemove, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rebuildRoutes();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }, 5000);Â 
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // Final Tip Box Update
Â  Â  document.getElementById("ai-tip").textContent = aiTipText;

Â  Â  // Dashboard updates use the AI-recommended values (eco.speed is the TARGET)
Â  Â  // For more realistic simulation, the *actual* speed should closely follow the eco.speed
Â  Â  currentSimulatedSpeed = eco.speed + (Math.random() * 5 - 2.5); // Slight random variation
Â  Â  currentSimulatedSpeed = Math.max(0, Math.min(100, currentSimulatedSpeed));

Â  Â  // Display actual simulated speed and AI-recommended gear/throttle
Â  Â  document.getElementById("speed").textContent = currentSimulatedSpeed.toFixed(0) + " km/h";
Â  Â  document.getElementById("gear").textContent = eco.gear;
Â  Â  document.getElementById("throttle").textContent = eco.throttle + "%";
}

/* ===== Route creation & step-box integration (Modified to initiate simulation) ===== */
async function createRoute(start, end, color, marker = null, index = null) {
Â  Â  // Stop any existing simulation
Â  Â  if(simulationInterval !== null) clearInterval(simulationInterval);

Â  Â  const endKey = `${end.lat.toFixed(6)},${end.lng.toFixed(6)}`;
Â  Â  const existing = routes.find(r => r.endKey === endKey);
Â  Â  if (existing) return;Â 
Â  Â Â 
Â  Â  const routeIndex = index !== null ? index : routes.length + 1;
Â  Â  const routeColor = color || colors[(routeIndex - 1) % colors.length];
Â  Â  const rc = L.Routing.control({
Â  Â  Â  Â  waypoints: [start, end],
Â  Â  Â  Â  router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' }),
Â  Â  Â  Â  show: false, addWaypoints: false, createMarker: () => null,
Â  Â  Â  Â  lineOptions: { styles: [{ color: routeColor, weight: 5, opacity: 0.9 }] }
Â  Â  }).addTo(map);
Â  Â  const group = L.layerGroup().addTo(map);

Â  Â  // Route box creation... (Same as original)
Â  Â  const box = document.createElement('div'); box.className = 'route-box';
Â  Â  const header = document.createElement('div'); header.className = 'route-header';
Â  Â  header.style.background = routeColor;
Â  Â  header.innerHTML = `<b>Route ${routeIndex}</b><button>âœ•</button>`;
Â  Â  const distanceInfo = document.createElement('div');
Â  Â  distanceInfo.className = 'route-distance-info';
Â  Â  distanceInfo.id = 'distanceToDest';
Â  Â  distanceInfo.textContent = 'Calculating distance...';
Â  Â  const content = document.createElement('div'); content.className = 'route-content';
Â  Â  content.style.display = 'block';
Â  Â  box.appendChild(header); box.appendChild(distanceInfo); box.appendChild(content);
Â  Â  document.getElementById('routePanel').appendChild(box);
Â  Â  header.onclick = () => content.style.display = content.style.display === 'block' ? 'none' : 'block';
Â  Â  header.querySelector('button').onclick = (e) => {
Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  map.removeControl(rc); map.removeLayer(group); box.remove();
Â  Â  Â  Â  const idx = routes.findIndex(r => r.rc === rc);
Â  Â  Â  Â  if (idx !== -1) { routes.splice(idx, 1); }
Â  Â  Â  Â  if (marker) {
Â  Â  Â  Â  Â  Â  const wpIdx = waypointMarkers.indexOf(marker);Â 
Â  Â  Â  Â  Â  Â  if (wpIdx !== -1) { map.removeLayer(marker); waypointMarkers.splice(wpIdx, 1); waypoints.splice(wpIdx + 1, 1); }
Â  Â  Â  Â  }
Â  Â  Â  Â  rebuildRoutes();
Â  Â  };

Â  Â  rc.on('routesfound', async e => {
Â  Â  Â  Â  const route = e.routes[0];
Â  Â  Â  Â  const coords = route.coordinates.map(c => ({ lat: c.lat, lng: c.lng }));
Â  Â  Â  Â  const elevs = await getElevations(coords);
Â  Â  Â  Â  const steps = [];
Â  Â  Â  Â  content.innerHTML = '';
Â  Â  Â  Â  const totalDistKm = (route.summary.totalDistance / 1000).toFixed(2);
Â  Â  Â  Â  distanceInfo.innerHTML = `<b>Total Route Distance: ${totalDistKm} km</b>`;
Â  Â  Â  Â Â 
Â  Â  Â  Â  route.instructions.forEach((s, j) => {
Â  Â  Â  Â  Â  Â  const idxStart = s.index;
Â  Â  Â  Â  Â  Â  const idxEnd = j + 1 < route.instructions.length ? route.instructions[j + 1].index : coords.length;
Â  Â  Â  Â  Â  Â  const segmentCoords = coords.slice(idxStart, idxEnd).map(c => [c.lat, c.lng]);
Â  Â  Â  Â  Â  Â  const elev = elevs[idxStart] || 0;
Â  Â  Â  Â  Â  Â  const stepLine = L.polyline(segmentCoords, { color: routeColor, weight: 5, opacity: 0.5 }).addTo(group);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // STORE the fixed original distance for the step!
Â  Â  Â  Â  Â  Â  const distanceText = s.distance > 1000 ? `${(s.distance / 1000).toFixed(2)} km` : `${s.distance.toFixed(0)} m`;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const item = document.createElement('div');
Â  Â  Â  Â  Â  Â  item.className = 'route-step';
Â  Â  Â  Â  Â  Â  item.innerHTML = `<b>${s.text}</b><div>${distanceText} | Elev ${elev.toFixed(1)} m</div>`;
Â  Â  Â  Â  Â  Â  content.appendChild(item);
Â  Â  Â  Â  Â  Â  item.addEventListener('mouseenter', () => stepLine.setStyle({ color: '#00FF00', weight: 6, opacity: 0.9 }));
Â  Â  Â  Â  Â  Â  item.addEventListener('mouseleave', () => stepLine.setStyle({ color: routeColor, weight: 5, opacity: 0.5 }));
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Store originalDistanceText
Â  Â  Â  Â  Â  Â  steps.push({ lat: coords[idxStart].lat, lng: coords[idxStart].lng, text: s.text, elev, element: item, spoken: false, distance: s.distance, line: stepLine, originalDistanceText: distanceText });
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  routes.push({ rc, group, steps, color: routeColor, endKey, box, endLatLng: end, totalDistance: route.summary.totalDistance, fullCoords: coords });
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (activeRouteIndex === null) {
Â  Â  Â  Â  Â  Â  activeRouteIndex = routes.length - 1;
Â  Â  Â  Â  }

Â  Â  Â  Â  // START THE CAR SIMULATION after route is found
Â  Â  Â  Â  if(routes.length === 1) {
Â  Â  Â  Â  Â  Â  simCoords = coords;
Â  Â  Â  Â  Â  Â  simIndex = 0;
Â  Â  Â  Â  Â  Â  simulateCarMovement();
Â  Â  Â  Â  Â  Â  speakCurrentStep(); // Announce the start of the route
Â  Â  Â  Â  }
Â  Â  });
}

/*=================== CAR MOVEMENT SIMULATION FUNCTION (FIXED) ====================*/

function getSimulatedHeading(p1, p2) {
Â  Â  const dLat = p2.lat - p1.lat;
Â  Â  const dLon = p2.lng - p1.lng;
Â  Â  const heading = Math.atan2(dLon, dLat) * 180 / Math.PI;
Â  Â  return (heading + 360) % 360; // Normalize to 0-360
}

function simulateCarMovement() {
Â  Â  if (simulationInterval !== null) clearInterval(simulationInterval);
Â  Â Â 
Â  Â  if (!routes.length || activeRouteIndex === null || !routes[activeRouteIndex].fullCoords.length) {
Â  Â  Â  Â  console.warn("No active route or coordinates for simulation.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  const route = routes[activeRouteIndex];
Â  Â  simCoords = route.fullCoords;
Â  Â  simIndex = 0;
Â  Â Â 
Â  Â  if (!userMarker) {
Â  Â  Â  Â  userMarker = L.marker(L.latLng(simCoords[0].lat, simCoords[0].lng), {icon: carIcon}).addTo(map);
Â  Â  Â  Â  waypoints.push(L.latLng(simCoords[0].lat, simCoords[0].lng));
Â  Â  Â  Â  map.setView(L.latLng(simCoords[0].lat, simCoords[0].lng), 14);
Â  Â  }
Â  Â Â 
Â  Â  const SIMULATION_STEP_MS = 500; // Time interval for each update (faster update for smoother feel)
Â  Â  const DISTANCE_PER_MS = 0.015; // Represents ~54 km/h (15m/s). This is the base speed.

Â  Â  simulationInterval = setInterval(async () => {
Â  Â  Â  Â  // **Crucial Fix for Car Stopping:** Ensure we don't try to read beyond the array
Â  Â  Â  Â  if (simIndex >= simCoords.length - 1) {
Â  Â  Â  Â  Â  Â  simIndex = simCoords.length - 1; // Ensure final point is hit
Â  Â  Â  Â  Â  Â  clearInterval(simulationInterval);
Â  Â  Â  Â  Â  Â  adaptiveAIDashboard(userMarker.getLatLng(), 0); // Trigger final update
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Calculate movement distance based on the **AI's recommended speed**
Â  Â  Â  Â  // We use the currentSimulatedSpeed (which is driven by eco advice)
Â  Â  Â  Â  const metersPerStep = (currentSimulatedSpeed / 3.6) * (SIMULATION_STEP_MS / 1000);
Â  Â  Â  Â Â 
Â  Â  Â  Â  let distanceTraveled = 0;
Â  Â  Â  Â  let nextIndex = simIndex;
Â  Â  Â  Â  let lastLatLng = L.latLng(simCoords[simIndex].lat, simCoords[simIndex].lng);

Â  Â  Â  Â  // Advance along the path until the calculated distance is covered
Â  Â  Â  Â  while (distanceTraveled < metersPerStep && nextIndex < simCoords.length - 1) {
Â  Â  Â  Â  Â  Â  nextIndex++;
Â  Â  Â  Â  Â  Â  const nextLatLng = L.latLng(simCoords[nextIndex].lat, simCoords[nextIndex].lng);
Â  Â  Â  Â  Â  Â  distanceTraveled += lastLatLng.distanceTo(nextLatLng);
Â  Â  Â  Â  Â  Â  lastLatLng = nextLatLng;
Â  Â  Â  Â  }

Â  Â  Â  Â  if (nextIndex === simIndex) {
Â  Â  Â  Â  Â  Â  // If the AI speed is too low to move even one coordinate in the interval, jump 1
Â  Â  Â  Â  Â  Â  nextIndex = Math.min(simIndex + 1, simCoords.length - 1);
Â  Â  Â  Â  }

Â  Â  Â  Â  const currentCoord = simCoords[simIndex];
Â  Â  Â  Â  const nextCoord = simCoords[nextIndex];
Â  Â  Â  Â  const latlng = L.latLng(nextCoord.lat, nextCoord.lng); // Move car to the new position
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Calculate heading for simulated movement
Â  Â  Â  Â  const heading = getSimulatedHeading(currentCoord, nextCoord);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Update marker position and view
Â  Â  Â  Â  userMarker.setLatLng(latlng);
Â  Â  Â  Â  map.setView(latlng, 14, {animate: false}); // Set to false for less lag
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Update user's current location in waypoints array
Â  Â  Â  Â  waypoints[0] = latlng;

Â  Â  Â  Â  // Run the main AI logic
Â  Â  Â  Â  await adaptiveAIDashboard(latlng, heading);

Â  Â  Â  Â  // Move the simulation index forward
Â  Â  Â  Â  simIndex = nextIndex;

Â  Â  }, SIMULATION_STEP_MS);
}

/*=================== END OF SIMULATION FUNCTION ====================*/


/*================Multi-step AI Tip Blending + Voice (Refined)=============*/
function speakCurrentStep() {
Â  Â  if (activeRouteIndex === null || routes[activeRouteIndex].steps.length === 0) return;
Â  Â Â 
Â  Â  const route = routes[activeRouteIndex];
Â  Â  const step = route.steps[0];
Â  Â Â 
Â  Â  // Use the full ecoAdvisor for the first announcement
Â  Â  const eco = ecoAdvisor(step.distance, step.elev, step.text);
Â  Â  const distanceText = step.originalDistanceText; // Use the stored, fixed distance
Â  Â  const aiTipText = `START: ${step.text} (${distanceText} total)`;
Â  Â  document.getElementById("ai-tip").textContent = aiTipText;
Â  Â Â 
Â  Â  // Set up a temporary tip takeover for the start
Â  Â  stepArrivalPending = true;
Â  Â  setTimeout(() => { stepArrivalPending = false; }, 3000);

Â  Â  if ("speechSynthesis" in window) {
Â  Â  Â  Â  if(speechSynthesis.speaking) speechSynthesis.cancel();
Â  Â  Â  Â  const msg = new SpeechSynthesisUtterance(
Â  Â  Â  Â  Â  Â  `Starting route. ${step.text} for ${distanceText}. ${eco.tip}`
Â  Â  Â  Â  );
Â  Â  Â  Â  msg.rate = 1; msg.pitch = 1;
Â  Â  Â  Â  speechSynthesis.speak(msg);
Â  Â  }
}

/* ===== Off-route adaptation (Simplified for single-route simulation) ===== */
function checkOffRoute(latlng){ /* Not needed in linear simulation */ }


/* ===== Rebuild Routes (Modified to initiate simulation after recalculation) ===== */
function rebuildRoutes(newStartLatlng = null){
Â  Â  if(simulationInterval !== null) clearInterval(simulationInterval); // Stop simulation

Â  Â  routes.forEach(r=>{ map.removeControl(r.rc); map.removeLayer(r.group); });
Â  Â  routes=[]; document.getElementById('routePanel').innerHTML='';
Â  Â Â 
Â  Â  const startPoint = newStartLatlng || (waypoints.length ? waypoints[0] : null);

Â  Â  if(waypoints.length < 2 || !startPoint) return;
Â  Â Â 
Â  Â  // Recalculate route from current location to the final destination
Â  Â  const finalDestination = waypoints[waypoints.length-1];
Â  Â  // Use the last waypoint marker for the final destination
Â  Â  createRoute(startPoint, finalDestination, colors[0], waypointMarkers[waypointMarkers.length-1], 1);Â 
Â  Â  // Simulation will restart inside createRoute
}


/* ===== Add waypoint on map click (Unchanged, but now rebuilds single route) ===== */
map.on('click',e=>{
Â  Â  const latlng=e.latlng;Â 
Â  Â  const latlngKey = `${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`;
Â  Â  const isDuplicate = waypoints.slice(1).some(wp => `${wp.lat.toFixed(6)},${wp.lng.toFixed(6)}` === latlngKey);
Â  Â  if(isDuplicate) return;

Â  Â  // Clear old destination if one exists (to enforce single route simulation)
Â  Â  if(waypoints.length > 1) {
Â  Â  Â  Â  map.removeLayer(waypointMarkers.pop());
Â  Â  Â  Â  waypoints.pop();
Â  Â  }

Â  Â  waypoints.push(latlng);
Â  Â  const marker=L.marker(latlng).addTo(map); waypointMarkers.push(marker);
Â  Â Â 
Â  Â  // Always rebuild from current position to the new destination
Â  Â  rebuildRoutes();
});

/* ===== Search Suggestions (Unchanged, but calls rebuildRoutes) ===== */
const input=document.getElementById('searchInput');
const suggestBox=document.getElementById('suggestBox');
let results=[];
input.oninput=async()=>{
Â  Â  const q=input.value.trim();
Â  Â  if(!q){suggestBox.style.display='none';return;}
Â  Â  const d=await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&limit=12`)
Â  Â  Â  Â  .then(r=>r.json()).catch(()=>({features:[]}));
Â  Â  results=d.features||[];
Â  Â  suggestBox.innerHTML='';
Â  Â  results.forEach((f,i)=>{
Â  Â  Â  Â  const p=f.properties||{},name=p.name||p.city||'Unknown';
Â  Â  Â  Â  const info=[p.state,p.country].filter(Boolean).join(', ');
Â  Â  Â  Â  const div=document.createElement('div');
Â  Â  Â  Â  div.className='suggest-item';
Â  Â  Â  Â  div.innerHTML=`<b>${name}</b><div style="font-size:12px;color:#bbb;">${info}</div>`;
Â  Â  Â  Â  div.onclick=()=>selectResult(i);
Â  Â  Â  Â  suggestBox.appendChild(div);
Â  Â  });
Â  Â  suggestBox.style.display=results.length?'block':'none';
};
document.addEventListener('click',e=>{
Â  Â  if(!suggestBox.contains(e.target)&&e.target!==input)suggestBox.style.display='none';
});

function selectResult(i){
Â  Â  const f=results[i]; if(!f)return;
Â  Â  const [lng,lat]=f.geometry.coordinates; const latlng=L.latLng(lat,lng);
Â  Â Â 
Â  Â  const latlngKey = `${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`;
Â  Â  const isDuplicate = waypoints.slice(1).some(wp => `${wp.lat.toFixed(6)},${wp.lng.toFixed(6)}` === latlngKey);
Â  Â  if(isDuplicate) { input.value = ''; suggestBox.style.display = 'none'; return; }

Â  Â  // Clear old destination if one exists (to enforce single route simulation)
Â  Â  if(waypoints.length > 1) {
Â  Â  Â  Â  map.removeLayer(waypointMarkers.pop());
Â  Â  Â  Â  waypoints.pop();
Â  Â  }
Â  Â Â 
Â  Â  waypoints.push(latlng);
Â  Â  const marker=L.marker(latlng).addTo(map);
Â  Â  waypointMarkers.push(marker);
Â  Â Â 
Â  Â  rebuildRoutes(); // Always rebuild from current position to the new destination
Â  Â  input.value=''; suggestBox.style.display='none';
}


/* ===== Map Toggle (Unchanged) ===== */
let mapFull=false;
document.getElementById("map-toggle").addEventListener("click",()=>{
Â  Â  const mapContainer=document.querySelector(".map-container");
Â  Â  const button=document.getElementById("map-toggle");
Â  Â  if(!mapFull){
Â  Â  Â  Â  mapContainer.style.position="fixed"; mapContainer.style.top="0"; mapContainer.style.left="0"; mapContainer.style.width="100vw"; mapContainer.style.height="100vh"; mapContainer.style.zIndex="2000";
Â  Â  Â  Â  button.innerText="Restore Map"; mapFull=true; setTimeout(()=>map.invalidateSize(),300);
Â  Â  }else{
Â  Â  Â  Â  mapContainer.style.position=""; mapContainer.style.width=""; mapContainer.style.height=""; mapContainer.style.zIndex="";
Â  Â  Â  Â  button.innerText="Full Map"; mapFull=false; setTimeout(()=>map.invalidateSize(),300);
Â  Â  }
});

/* ===== Initial Marker Placement (Simulated GPS start) ===== */
if (!userMarker && waypoints.length === 0) {
Â  Â  // Initial start location for the simulation (Mumbai)
Â  Â  const startLatLng = L.latLng(24.7228, 46.6226);
Â  Â  waypoints.push(startLatLng);
Â  Â  userMarker = L.marker(startLatLng, {icon: carIcon}).addTo(map);
}

// Initial Call to place the first marker (if no real GPS is used)
adaptiveAIDashboard(L.latLng(19.076, 72.8777), 0);

</script>
</body>
</html>
