<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Eco Driving Dashboard</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
<style>
*{box-sizing:border-box;margin:0;padding:0;}
body{
background:radial-gradient(circle at top left,#2a4b7a,#1c2b44,#2a3b60);
font-family:"Segoe UI",Arial,sans-serif;color:#fff;
height:100vh;display:flex;flex-direction:column;overflow:hidden;
}
/* === HEADER === */
.ai-tip-box{flex:0 0 auto;background:#ffa500;color:#000;border-radius:1vh;
margin:1vh 2vw;padding:1.5vh 1vw;text-align:center;font-weight:bold;
font-size:clamp(1rem,2vw,1.6rem);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.stats-row{display:flex;justify-content:space-evenly;align-items:stretch;
flex-wrap:wrap;gap:1vh;margin:0 1vw;}
.stat-card{flex:1;min-width:120px;max-width:180px;background:rgba(28,34,48,0.95);
border-radius:1vh;padding:1vh;display:flex;flex-direction:column;justify-content:center;
align-items:center;text-align:center;border:1px solid rgba(255,255,255,0.2);
box-shadow:0 0.3vh 1vh rgba(0,0,0,0.4);}
.stat-label{font-size:0.9rem;opacity:0.8;}
.stat-value{font-size:1.3rem;font-weight:bold;margin-top:0.3rem;}
.speed-box{background:#4e79a7;}
.gear-box{background:#76b7b2;color:#000;}
.throttle-box{background:#2ca02c;color:#000;}
/* === SEARCH === */
.search-row{display:flex;align-items:center;justify-content:center;gap:1vw;margin:1vh 2vw;position:relative;}
#searchInput{flex:1;max-width:70%;padding:0.8vh 1vw;font-size:1rem;border-radius:1vh;
border:none;outline:none;}
#micBtn{background:#ff4c4c;color:#fff;border:none;border-radius:1vh;padding:0.8vh 1.2vw;
font-weight:bold;cursor:pointer;box-shadow:0 0.4vh 1vh rgba(0,0,0,0.3);}
#suggestBox{position:absolute;top:100%;left:10%;width:80%;background:rgba(0,0,0,0.9);
border-radius:1vh;max-height:40vh;overflow-y:auto;z-index:2000;display:none;}
.suggest-item{padding:0.8vh 1vw;border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer;}
.suggest-item:hover{background:rgba(255,255,255,0.1);}
/* === MAIN (Map now fills space) === */
.main-section{flex:1;display:flex;flex-direction:column;gap:1vh;padding:0 2vw 1vh;}
.map-container{flex:1;position:relative;border-radius:1vh;overflow:hidden;
border:1px solid rgba(255,255,255,0.2);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.map{width:100%;height:100%;}
/* === Locate (Target) Button === */
#locate-btn {
  position: absolute;
  bottom: 2vh;
  right: 1vh;
  z-index: 1000;
  background: #1e90ff;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 42px;
  height: 42px;
  font-size: 1.2rem;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 0.4vh 1vh rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  transition: transform 0.2s ease, background 0.3s ease;
}
#locate-btn:hover {background: #4682b4;transform: scale(1.1);
}
#map-toggle{position:absolute;top:1vh;right:1vh;z-index:1000;background:#ff8c00;
border:none;border-radius:1vh;padding:0.5vh 1vw;font-weight:bold;cursor:pointer;color:#000;}
/* === ROUTE PANEL === */
#routePanel{position:absolute;bottom:2vh;left:2vw;width:270px;max-height:42vh;
overflow-y:auto;background:rgba(0,0,0,0.6);border-radius:1vh;padding:0.5vh;color:#fff;z-index:999;}
.route-box{margin-bottom:0.8vh;border-radius:1vh;overflow:hidden;background:rgba(255,255,255,0.05);backdrop-filter:blur(6px);box-shadow:0 0.4vh 1vh rgba(0,0,0,0.5);}
.route-header{padding:0.6vh 0.6vw;font-weight:bold;display:flex;justify-content:space-between;
align-items:center;color:#fff;font-size:0.9rem;}
.route-content{background:rgba(255,255,255,0.1);padding:0.4vh 0.6vw;font-size:0.85rem;max-height:30vh;overflow-y:auto;transition:all 0.3s ease;}
.route-step{padding:0.4vh 0.3vw;margin-bottom:0.4vh;border-bottom:1px solid rgba(255,255,255,0.1);}
.route-step:hover{background:rgba(255,255,255,0.15);}

/* Car Icon Style (Updated for Car) */
.user-car-icon {
    width: 32px;
    height: 32px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.user-car-svg {
    transform-origin: center;
    transition: transform 0.3s linear;
}
/* === Slide-up Approval Panel === */
#approvalPanel{
  position:absolute;
  left:50%;
  bottom:1.5vh;
  transform:translate(-50%, 130%);
  width:min(92vw,460px);
  background:rgba(20,24,36,0.96);
  border:1px solid rgba(255,255,255,0.15);
  border-radius:14px;
  box-shadow:0 0.8vh 2vh rgba(0,0,0,0.5);
  padding:12px 14px;
  z-index:1100;
  transition:transform .28s ease;
  backdrop-filter:blur(6px);
}
#approvalPanel.show{ transform:translate(-50%, 0); }

.approval-row{ display:flex; gap:10px; align-items:center; }
.approval-icon{
  flex:0 0 40px; height:40px; border-radius:10px;
  display:flex; align-items:center; justify-content:center;
  background:#24324f; font-size:1.2rem;
}
.approval-main{ flex:1; min-width:0; }
.approval-title{ font-weight:700; font-size:0.98rem; line-height:1.2; }
.approval-sub{ font-size:0.82rem; opacity:0.8; margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

.approval-actions{ display:flex; gap:10px; margin-top:10px; }
.btn-ghost, .btn-solid{
  flex:1; padding:10px 12px; border-radius:10px; font-weight:700; border:none; cursor:pointer;
  box-shadow:0 0.4vh 1.2vh rgba(0,0,0,0.35);
}
.btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.22); color:#fff; }
.btn-ghost:hover{ background:rgba(255,255,255,0.07); }
.btn-solid{ background:#00b36b; color:#fff; }
.btn-solid:hover{ filter:brightness(0.95); }

.approval-chips{ display:flex; gap:8px; margin-top:6px; }
.chip{
  font-size:0.78rem; padding:5px 8px; border-radius:8px;
  background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12);
}

</style>
</head>
<body>
<div class="ai-tip-box" id="ai-tip">Starting system...</div>
<div class="stats-row">
Â  <div class="stat-card speed-box"><div class="stat-label">Speed</div><div class="stat-value" id="speed">0 km/h</div></div>
Â  <div class="stat-card gear-box"><div class="stat-label">Gear</div><div class="stat-value" id="gear">N</div></div>
Â  <div class="stat-card throttle-box"><div class="stat-label">Throttle</div><div class="stat-value" id="throttle">0%</div></div>
</div>

<div class="search-row">
Â  <input type="text" id="searchInput" placeholder="Search destination...">
Â  <button id="micBtn">ğŸ¤</button>
Â  <div id="suggestBox"></div>
</div>

<div class="main-section">
Â  <div class="map-container">
Â  Â  <div id="map" class="map"></div>
Â  Â  <button id="map-toggle">Full Map</button>
      <!-- ğŸ†• Locate Me (Target) Button -->
    <button id="locate-btn" title="Recenter to my location">ğŸ¯</button>
Â  Â  <div id="routePanel"></div>
    <!-- Route Approval Panel (hidden by default) -->
    <div id="approvalPanel" aria-live="polite">
      <div class="approval-row">
        <div class="approval-icon">ğŸ“</div>
        <div class="approval-main">
          <div class="approval-title" id="approvalTitle">Start navigation?</div>
          <div class="approval-sub" id="approvalSubtitle">Destination</div>
          <div class="approval-chips">
            <div class="chip" id="approvalDistance">â€”</div>
            <div class="chip" id="approvalDuration">â€”</div>
          </div>
        </div>
      </div>
      <div class="approval-actions">
        <button id="approvalCancel" class="btn-ghost">Cancel</button>
        <button id="approvalStart"  class="btn-solid">Start</button>
      </div>
    </div>
Â  </div>
</div> <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script> 
// âœ… Enable rotation by applying transform on the map container
let currentMapRotation = 0;

function rotateMap(angle) {
    currentMapRotation = angle;

    const mapPane = map.getPane('mapPane');
    if (mapPane) {
        mapPane.style.transform = `rotate(${angle}deg)`;
        mapPane.style.transformOrigin = "center center";
    }

    // âœ… Keep interaction correct by rotating controls opposite direction
    const controlPane = map.getPane('controlPane');
    if (controlPane) {
        controlPane.style.transform = `rotate(${-angle}deg)`;
    }
}
/* ===== Map Init ===== */
// Setting a non-specific initial view. GPS will immediately overwrite this to the user's actual location.
const map=L.map('map').setView([0, 0], 2); 
let autoFollow = true; // Track whether we should auto-follow the car
/* =====Multilingual Speech ===== */
function detectLang(text) {
  if (/[Ø£-ÙŠ]/.test(text)) return "ar-SA";
  if (/[Ğ°-Ñ]/i.test(text)) return "ru-RU";
  if (/[à¸-à¹™]/.test(text)) return "th-TH";
  if (/[×-×ª]/.test(text)) return "he-IL";
  if (/[Î±-Ï‰]/i.test(text)) return "el-GR";
  return "en-US";
}

// 1ï¸âƒ£ English Map (CartoDB Positron â€” clean English-only)
var englishMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; OpenStreetMap contributors | Â© CartoDB',
    subdomains: 'abcd',
    maxZoom: 19
});

// 2ï¸âƒ£ Google Streets Map
var googleMap = L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
    maxZoom: 23,
    subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
});

// 3ï¸âƒ£ Normal OSM Map (Default)
var osmMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
});

// Default layer
googleMap.addTo(map);

/* === Add Map Layer Control (Top Right Corner) === */
L.control.layers(
  {
    "ğŸ—ºï¸ English Map": englishMap,
    "ğŸŒ Google Map": googleMap,
    "ğŸ—ºï¸ Map": osmMap,
  },
  null,
  { position: "topright", collapsed: true }
).addTo(map);

// NEW: Use L.divIcon for a rotating car icon
const carIcon = L.divIcon({
    className: 'user-car-icon',
    // Simple car shape pointing up (North=0deg). Change fill color to a darker shade for better visibility.
    html: '<svg id="user-car-svg" class="user-car-svg" width="32" height="32" viewBox="0 0 100 100" fill="#2a3b60" stroke="#fff" stroke-width="3"><path d="M 25 20 L 75 20 L 80 45 L 90 45 L 90 70 L 10 70 L 10 45 L 20 45 Z" /></svg>',
    iconSize: [32, 32],
    iconAnchor: [16, 16] // Center of the icon
});

let userMarker=null,waypoints=[],waypointMarkers=[],routes=[],totalFuel=0;
const colors=['#FF6B6B','#4DA6FF','#FFD93D','#6BCB77','#FF8C00','#9B59B6','#00BFA5'];
/* ===== Speech Memory System ===== */
let lastSpeech = {
  type: null,           // "step" | "tip" | "warning"
  text: "",
  timestamp: Date.now(),
  stepIndex: 0,         // last spoken step
  routeIndex: 0         // last active route
};

function rememberSpeech(type, text) {
  lastSpeech.type = type;
  lastSpeech.text = text;
  lastSpeech.timestamp = Date.now();
  lastSpeech.stepIndex = currentStepIndex;
  lastSpeech.routeIndex = activeRouteIndex;
}
// Store for road type information
let currentRoadType = "city"; 
let lastStepLatLng = null;
let lastStepAdvanceTime = 0;
let lastSlope = 0;
let lastSlopeCategory = "";
let lastEcoVoiceTime = 0;


/* ===== Preview Route State ===== */
let preview = {
  active: false,
  group: null,
  polyline: null,
  osrmRoute: null,
  start: null,
  end: null,
  destLabel: "",
  tempMarker: null
};

const approvalPanel = document.getElementById("approvalPanel");
const approvalTitle = document.getElementById("approvalTitle");
const approvalSubtitle = document.getElementById("approvalSubtitle");
const approvalDistance = document.getElementById("approvalDistance");
const approvalDuration = document.getElementById("approvalDuration");
const approvalStartBtn = document.getElementById("approvalStart");
const approvalCancelBtn = document.getElementById("approvalCancel");

/* Format helpers */
function fmtKm(m){ return (m/1000).toFixed(m>=10000 ? 0 : 1) + " km"; }
function fmtMin(s){
  const m = Math.round(s/60);
  if (m < 60) return m + " min";
  const h = Math.floor(m/60), mm = m%60;  
  return `${h} hr ${mm?mm+" min":""}`.trim();
}

/* Clear preview visuals/state */
function clearPreview(){
  if (preview.polyline && preview.group){
    try { preview.group.removeLayer(preview.polyline); } catch {}
  }
  if (preview.group){ try { map.removeLayer(preview.group); } catch {} }
  if (preview.tempMarker){ try { map.removeLayer(preview.tempMarker); } catch {} }

  preview = {
    active:false, group:null, polyline:null, osrmRoute:null,
    start:null, end:null, destLabel:"", tempMarker:null
  };
  approvalPanel.classList.remove("show");
}

/* Build preview polyline using OSRM (same path quality as route) */
function buildPreviewRoute(startLL, endLL, labelText){
  clearPreview();

  const router = L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' });
  const wp = [{ latLng: L.latLng(startLL) }, { latLng: L.latLng(endLL) }];

  router.route(wp, (err, routesResp) => {
    if (err || !routesResp || !routesResp[0]) {
      console.warn("Preview routing failed:", err);
      return;
    }
    const r = routesResp[0];
    preview.active = true;
    preview.osrmRoute = r;
    preview.start = L.latLng(startLL);
    preview.end = L.latLng(endLL);
    preview.destLabel = labelText || "Selected destination";
    preview.group = L.layerGroup().addTo(map);

    // Same visual style as your routes (no dashes, proper path)
    preview.polyline = L.polyline(
      r.coordinates.map(c => [c.lat, c.lng]),
      { color: '#4DA6FF', weight: 5, opacity: 0.9 }
    ).addTo(preview.group);

    // Populate panel
    approvalTitle.textContent = "Start navigation?";
    approvalSubtitle.textContent = preview.destLabel;
    approvalDistance.textContent = fmtKm(r.summary.totalDistance);
    approvalDuration.textContent = fmtMin(r.summary.totalTime);

    // Show panel
    approvalPanel.classList.add("show");

    // Do NOT start step boxes/speech/tips here (preview mode)
  });
}

/* Open preview from a latlng + label; optionally add a temporary marker */
function openPreviewTo(latlng, label, addTempMarker = true){
  const start = userMarker ? userMarker.getLatLng() : map.getCenter();
  if (addTempMarker){
    // remove previous temp marker if any
    if (preview.tempMarker) { try { map.removeLayer(preview.tempMarker); } catch {} }
    preview.tempMarker = L.marker(latlng).addTo(map);
  }
  buildPreviewRoute(start, latlng, label);
}
// Start -> convert preview into an official route
approvalStartBtn.addEventListener("click", () => {
  if (!preview.active || !preview.end) return;

  // ensure waypoint[0] is current driver position
  const start = userMarker ? userMarker.getLatLng() : map.getCenter();
  if (!waypoints.length) waypoints.push(start); else waypoints[0] = start;

  // make a persistent destination marker
  const destMarker = L.marker(preview.end).addTo(map);
  waypointMarkers.push(destMarker);
  waypoints.push(preview.end);

  // close preview visuals/panel first
  const endLL = preview.end;
  clearPreview();

  // create real route (this builds boxes, speech, eco, etc.)
  createRoute(waypoints[waypoints.length - 2], endLL, colors[routes.length % colors.length], destMarker);

  // keep autoFollow behavior as you already set elsewhere
});

// Cancel -> remove preview completely
approvalCancelBtn.addEventListener("click", () => {
  clearPreview();
});

/* ===== Road Type Detection (FIXED for Global Use) ===== */
async function getRoadType(latlng) {
    // --- START FIX: Removed Mumbai-centric logic for global use. ---
    
    // MOCK LOGIC: Use current GPS speed to estimate road type globally.
    // NOTE: calculateGPSSpeed is defined later but accessible via hoisting.
    const speed = calculateGPSSpeed(latlng); 
    
    if (speed > 80) { // High speed suggests highway
        currentRoadType = "highway";
    } else if (speed > 40) { // Medium speed suggests residential or main city road
        currentRoadType = "residential";
    } else if (speed > 10) { // Low speed suggests city/stop-and-go traffic
        currentRoadType = "city";
    } else {
        // Default or stationary
        currentRoadType = "residential";
    }
    
    // Retain mountain/offroad randomness for flavor, as we can't determine it without an API
    if (Math.random() < 0.05) { 
         currentRoadType = Math.random() < 0.5 ? "mountain" : "national highway";
    }
    
    // --- END FIX: Removed Mumbai-centric logic for global use. ---
    return currentRoadType;
}

/* ===== Eco Advisor (MODIFIED for simplicity) ===== */
function ecoAdvisor(distAhead, slope, turnText) {
    let tip = "";
    let speed = 40;
    let gear = 3;
    let throttle = 45;

    // âœ… Road type logic
    switch (currentRoadType) {
        case "highway":
        case "national highway":
            speed = 80; gear = 5; throttle = 55;
            tip = "Highway â€” maintain steady speed.";
            break;

        case "city":
            speed = 30; gear = 3; throttle = 40;
            tip = "City driving â€” anticipate stops.";
            break;

        case "residential":
            speed = 25; gear = 3; throttle = 35;
            tip = "Residential zone â€” maintain low speed.";
            break;

        case "mountain":
            speed = 35; gear = 2; throttle = 50;
            tip = "Mountain road â€” use engine braking.";
            break;

        default:
            tip = "Maintain smooth driving.";
            break;
    }

    // âœ… Slope logic
    if (slope > 2.5) {
        tip += " Downhill ahead.";
    } 
    else if (slope < -2.5) {
        tip += " Uphill ahead.";
    }

    // âœ… Straight road
    if (distAhead > 700 && Math.abs(slope) < 3) {
        tip += " Long straight road ahead.";
    }

    return { speed, gear, throttle, tip, slope };
}

/* ===== Speech Visibility Failsafe ===== */
document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
        // Resume speech engine
        try { speechSynthesis.resume(); } catch {}
        // Auto speak the last active line (step/tip/warning)
        if (lastSpeech.text) {
            const msg = new SpeechSynthesisUtterance(lastSpeech.text);
            msg.rate = 1; msg.pitch = 1;
            rememberSpeech(lastSpeech.type || "tip", msg.text);
            speechSynthesis.speak(msg);
        }
    }
});
/* ===== Speech Watchdog (Every 3s) ===== */
/* ===== Auto-Repeat Watchdog (every 5 sec) ===== */
setInterval(() => {
    // Speak only if app visible
    if (document.visibilityState !== "visible") return;

    const idleTime = Date.now() - lastSpeech.timestamp;

    // If speech engine stalled for > 10 seconds â†’ repeat last line
    if (!speechSynthesis.speaking && idleTime > 15000 && (lastSpeech.type === "step" || lastSpeech.type === "warning")) {
        console.warn("ğŸ” Auto-repeat triggered:", lastSpeech.text);

        try { speechSynthesis.cancel(); } catch {}
        const msg = new SpeechSynthesisUtterance(lastSpeech.text);
        msg.rate = 1; msg.pitch = 1;
        speechSynthesis.speak(msg);

        lastSpeech.timestamp = Date.now(); // refresh memory timestamp
    }
}, 5000);

/* âœ… SMART TIP ENGINE â€” Every 15 sec, no repetition, dynamic */
let lastTip = "";
let lastTipTime = 0;

function speakEco(eco) {
    const now = Date.now();
    

    // Avoid spam
    if (now - lastEcoVoiceTime < 12000) return;

    // Priority (warning â†’ step â†’ eco)
    if (lastSpeech.type === "warning" || lastSpeech.type === "step") return;

    lastEcoVoiceTime = now;

    const msg = new SpeechSynthesisUtterance(
        `${eco.tip} Road type: ${currentRoadType}.`
    );

    msg.rate = 1;
    msg.pitch = 1;

    rememberSpeech("tip", msg.text);
    speechSynthesis.speak(msg);
}

/* ===== Driver Behavior Monitoring (Unchanged) ===== */
let driverStats = { overspeed: 0, harshAccel: 0, totalPoints: 0 };
let spokenWarnings = new Set();Â  

function updateDriverBehavior(currentSpeed, eco) {
Â  Â  driverStats.totalPoints++;
Â  Â  let warnings = [];

Â  Â  // Overspeed detection
Â  Â  if (currentSpeed > eco.speed + 10) { // Increased tolerance to 10km/h
Â  Â  Â  Â  driverStats.overspeed++;
Â  Â  Â  Â  if (!spokenWarnings.has('overspeed') || driverStats.overspeed % 10 === 0) { // Speak initially and then every 10 counts
Â  Â  Â  Â  Â  Â  warnings.push("Excessive speed detected");
Â  Â  Â  Â  Â  Â  spokenWarnings.add('overspeed');
Â  Â  Â  Â  }
Â  Â  } else {
        spokenWarnings.delete('overspeed'); // Clear warning if speed is fine
    }

Â  Â  document.getElementById("throttle").dataset.lastThrottle = eco.throttle;

Â  Â  // Voice alert for warnings
Â  Â  if ('speechSynthesis' in window && warnings.length) {
Â  Â  Â  Â  const msg = new SpeechSynthesisUtterance(warnings.join(" "));
Â  Â  Â  Â  msg.rate = 1.2; msg.pitch = 1.2; // Make warnings more distinct
Â  Â  Â  Â  // DO NOT cancel step or warning speech
        if (lastSpeech.type !== "warning") {
            try { speechSynthesis.cancel(); } catch {}
        }
        // Cancel step speech for urgent warning
        rememberSpeech("warning", msg.text);
Â  Â  Â  Â  speechSynthesis.speak(msg);
        // âœ… Resume logic after warning finishes
        msg.onend = () => {
            lastSpeech.timestamp = Date.now();

            // If a route is active â†’ resume navigation step
            if (activeRouteIndex !== null && routes[activeRouteIndex]) {
                try { speakCurrentStep(); } catch {}
            }
            // If no route â†’ resume tip engine
            else if (lastSpeech.type === "tip") {
                const t = new SpeechSynthesisUtterance(lastSpeech.text);
                speechSynthesis.speak(t);
            }
        };
Â  Â  Â  Â  
        // Show overspeeding warning in tip box too
        if (warnings.includes("Excessive speed detected")) {
             document.getElementById("ai-tip").textContent = "âš ï¸ OVERSPEED WARNING âš ï¸";
        }
Â  Â  }
}
/* ===== Overspeed Alert + Speech Stability ===== */
function cancelSpeech() { try { speechSynthesis.cancel(); } catch {} }

function overspeedWarning(currentSpeed, ecoSpeed) {
  if (currentSpeed > ecoSpeed + 10) {
    const warn = `âš ï¸ Overspeed! Reduce speed to ${ecoSpeed} km/h`;
    document.getElementById("ai-tip").textContent = warn;
    cancelSpeech();
    const msg = new SpeechSynthesisUtterance(warn);
    msg.lang = detectLang(step.text);
    msg.rate = 1.1;
    rememberSpeech("warning", msg.text);
    speechSynthesis.speak(msg);
  }
}

// dynamicEcoAdvisor is now primarily handled by the improved ecoAdvisor which integrates road type
function dynamicEcoAdvisor(currentSpeed, slopeAhead, distToNextStep){
    return ecoAdvisor(distToNextStep, slopeAhead, "");
}

async function getElevations(coords){
Â  Â  try{
Â  Â  Â  Â  const locs=coords.map(p=>`${p.lat},${p.lng}`).join('|');
Â  Â  Â  Â  // Using a CORS-enabled proxy for Open-Elevation or a mock response
        // In this environment, we'll mock the call to prevent errors.
Â  Â  Â  Â  // const r=await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(locs)}`);
Â  Â  Â  Â  // const d=await r.json();
Â  Â  Â  Â  // return d.results.map(x=>x.elevation);
        
        // Mocking elevation results for a more stable demo
        return new Array(coords.length).fill(0).map((_, i) => Math.sin(i * 0.1) * 50 + Math.random() * 5);

Â  Â  }catch{return new Array(coords.length).fill(0);}
}

/* ===== Multi-Step Route Awareness (Unchanged) ===== */
async function getUpcomingSteps(latlng, maxSteps=5){
Â  if(!routes.length) return [];
Â  const upcomingSteps=[];
Â  routes.forEach(r=>{
Â  Â  let nearestIdx=-1, minDist=Infinity;
Â  Â  r.steps.forEach((s,i)=>{
Â  Â  Â  const d=latlng.distanceTo([s.lat,s.lng]);
Â  Â  Â  if(d<minDist){ minDist=d; nearestIdx=i; } 
Â  Â  });
Â  Â  if(nearestIdx!==-1){
Â  Â  Â  for(let j=nearestIdx; j<Math.min(r.steps.length, nearestIdx+maxSteps); j++){
Â  Â  Â  Â  upcomingSteps.push(r.steps[j]);
Â  Â  Â  }
Â  Â  }
Â  });
Â  return upcomingSteps;
}

/* ====== Step-by-Step AI Voice Guidance & Dashboard Update (FIXED) ====== */
let activeRouteIndex = null;
let currentStepIndex = 0;
let nextStepReady = true;
let speechTimer = null; // Failsafe timer

async function adaptiveAIDashboard(latlng, heading) {
Â  // 1. Get Real-time Data
Â  const currentSpeed = calculateGPSSpeed(latlng);
Â  const slopeData = await predictElevationAhead(latlng, heading);
Â  const slope = slopeData.slope;
Â  await getRoadType(latlng); // Update global currentRoadType
Â 
Â  // 2. Calculate Eco Advice (Always based on real-time data)
Â  const eco = dynamicEcoAdvisor(currentSpeed, slope, 800); // Use 800m lookahead distance for general advice
  lastSlope = slope;
  // ğŸ‘‡ While preview is open:
  if (preview.active) {
    // Keep driver behavior & dashboard numbers updating
    const eco = dynamicEcoAdvisor(currentSpeed, slope, 800);
    updateDriverBehavior(currentSpeed, eco);
    overspeedWarning(currentSpeed, eco.speed);
    document.getElementById("speed").textContent = eco.speed + " km/h";
    document.getElementById("gear").textContent = eco.gear;
    document.getElementById("throttle").textContent = eco.throttle + "%";

    // IMPORTANT: do NOT touch ai-tip here (no nav eco tips / no speech)
    return; // â† skip the routing guidance part below
  }
Â 
Â  // 3. Route Guidance Logic
Â  if (activeRouteIndex !== null && routes.length > 0 && routes[activeRouteIndex]) {
Â  Â  const route = routes[activeRouteIndex];
Â  Â  const steps = route.steps;
Â  Â  const routeDisplayIndex = route.routeIndex;

Â  Â  if (currentStepIndex < steps.length) {
Â  Â  Â  const step = steps[currentStepIndex];
Â  Â  Â  const stepLatLng = L.latLng(step.lat, step.lng);
Â  Â  Â  const distanceToStep = latlng.distanceTo(stepLatLng);

Â  Â  Â  // Remaining Distance Calculation
Â  Â  Â  let remainingDistance = distanceToStep;
Â  Â  Â  for (let i = currentStepIndex + 1; i < steps.length; i++) {
Â  Â  Â  Â  remainingDistance += steps[i].distance;
Â  Â  Â  }
Â  Â  Â  const distanceEl = document.getElementById(`route-distance-${routeDisplayIndex}`);
Â  Â  Â  if (distanceEl) {
Â  Â  Â  Â  distanceEl.textContent = `${(remainingDistance / 1000).toFixed(1)} km remaining`;
Â  Â  Â  }

Â  Â  Â  // Update Tip Box with upcoming step
Â  Â  Â  const upcomingStepDistance = step.distance < 1000 ? `${step.distance.toFixed(0)} m` : `${(step.distance / 1000).toFixed(1)} km`;
      document.getElementById("ai-tip").textContent = `Next: ${step.text} (${upcomingStepDistance})`;
      if (!driverCountry) updateDriverCountry(latlng);

Â  Â  Â  // Voice/Step Trigger (FIXED)
Â  Â  Â  if (distanceToStep <= 20 && nextStepReady) { // Trigger earlier at 100m
Â  Â  Â  Â  nextStepReady = false; // LOCK
Â  Â  Â  Â  
Â  Â  Â  Â  // Get specific eco advice for the upcoming turn (using the old eco advisor with step data)
Â  Â  Â  Â  const stepEco = ecoAdvisor(step.distance, step.elev, step.text); 

Â  Â  Â  Â  // Determine distance for speech
Â  Â  Â  Â  const stepDistanceSpeech = step.distance < 1000 ? `${step.distance.toFixed(0)} meters` : `${(step.distance / 1000).toFixed(1)} kilometers`;

        // âœ… Step speech only (NO ECO TIPS)
        if ("speechSynthesis" in window) {
            try { speechSynthesis.cancel(); } catch {}

            const stepMsg = new SpeechSynthesisUtterance(`${step.text}. Proceed for ${stepDistanceSpeech}.`);
            stepMsg.rate = 1; 
            stepMsg.pitch = 1;

            stepMsg.onend = () => {
                // Advance step after speaking
                advanceStep();
                nextStepReady = true;
            };

            document.getElementById("ai-tip").textContent = `Next: ${step.text} (${stepDistanceSpeech})`;

            rememberSpeech("step", stepMsg.text);
            try { speechSynthesis.resume(); } catch {}
            speechSynthesis.speak(stepMsg);
        }
Â  Â  Â  Â    else {
            // Remove current step visuals
            if (step.element) step.element.remove();
            if (step.lineLayer) route.group.removeLayer(step.lineLayer);
            if (step.connectorLine) route.group.removeLayer(step.connectorLine);
            // Also remove the connecting line to next step (if any)
            if (step.connectorLine) route.group.removeLayer(step.connectorLine);
Â  Â  Â  Â  Â  Â  currentStepIndex++;
Â  Â  Â  Â  Â  Â  nextStepReady = true;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  // Route finished
      // âœ… Destination reached logic with 10m radius auto-removal
      const finalStep = steps[steps.length - 1];
      const destLL = L.latLng(finalStep.lat, finalStep.lng);
      const distToDest = latlng.distanceTo(destLL);

      if (distToDest <= 10) {

          // Speak only once
          if ("speechSynthesis" in window) {
              try { speechSynthesis.cancel(); } catch {}
              const endMsg = new SpeechSynthesisUtterance("Destination reached.");
              speechSynthesis.speak(endMsg);
          }

          document.getElementById("ai-tip").textContent = "Destination reached âœ…";

          // Remove route visuals
          try { map.removeControl(route.rc); } catch {}
          try { map.removeLayer(route.group); } catch {}

          // Remove waypoint marker
          const destIndex = waypointMarkers.length - 1;
          if (waypointMarkers[destIndex]) {
              map.removeLayer(waypointMarkers[destIndex]);
              waypointMarkers.splice(destIndex, 1);
              waypoints.splice(destIndex + 1, 1);
          }

          // Remove route box
          const box = document.getElementById(`route-box-${route.routeIndex}`);
          if (box) box.remove();

          // Remove from routes list
          routes.splice(activeRouteIndex, 1);

          // Reset engine
          activeRouteIndex = null;
          currentStepIndex = 0;
          nextStepReady = true;

          // Rebuild remaining chain
          rebuildRoutes();

          // Auto-activate next route (if any)
          if (routes.length > 0) {
              activeRouteIndex = 0;
              currentStepIndex = 0;
              nextStepReady = true;
              setTimeout(() => speakCurrentStep(), 300);
          }

          return; // âœ… FULL STOP
      }
Â  Â  }
Â  } else {
    // 4. Update Tip Box with General Eco Tip (when no route is active)
    document.getElementById("ai-tip").textContent = `Tip: ${eco.tip}`;
    speakEco(eco);
  }

Â  // 5. Apply dynamic eco hints and update dashboard (Always runs)
Â  updateDriverBehavior(currentSpeed, eco);
  overspeedWarning(currentSpeed, eco.speed);
Â  document.getElementById("speed").textContent = eco.speed + " km/h";
Â  document.getElementById("gear").textContent = eco.gear;
Â  document.getElementById("throttle").textContent = eco.throttle + "%";
}
function advanceStep() {
    const route = routes[activeRouteIndex];
    if (!route) return;

    const step = route.steps[currentStepIndex];
    if (step) {
        if (step.element) step.element.remove();
        if (step.lineLayer) route.group.removeLayer(step.lineLayer);
        if (step.connectorLine) route.group.removeLayer(step.connectorLine);
    }
    currentStepIndex++;
    nextStepReady = true;
    // Do not speak immediately after removing â†’ speakCurrentStep() handles next
    setTimeout(() => speakCurrentStep(), 300);
}

function speakCurrentStep() {
    if (activeRouteIndex === null || !routes[activeRouteIndex]) return;

    const route = routes[activeRouteIndex];
    const step = route.steps[currentStepIndex];
    if (!step) return;

    const stepDistanceSpeech = 
        step.distance < 1000 
            ? `${step.distance.toFixed(0)} meters`
            : `${(step.distance / 1000).toFixed(1)} kilometers`;

    if ("speechSynthesis" in window) {
        try { speechSynthesis.cancel(); } catch {}

        const stepMsg = new SpeechSynthesisUtterance(`${step.text}. Proceed for ${stepDistanceSpeech}.`);
        stepMsg.rate = 1; 
        stepMsg.pitch = 1;

        stepMsg.onend = () => {
            currentStepIndex++;
            nextStepReady = true;
        };

        document.getElementById("ai-tip").textContent =
            `Next: ${step.text} (${stepDistanceSpeech})`;

        rememberSpeech("step", stepMsg.text);
        speechSynthesis.speak(stepMsg);
    }
}

/* ===== GPS speed and idle detection (Unchanged) ===== */
let lastLatLng=null, lastGPSPos=null, lastGPSTime=null, idleStart=null;
const IDLE_THRESHOLD=3, IDLE_TIME=60;
function checkIdle(latlng){
Â  Â  if(!lastLatLng){ lastLatLng=latlng; idleStart=Date.now(); return false; }
Â  Â  const dist=latlng.distanceTo(lastLatLng);
Â  Â  if(dist<IDLE_THRESHOLD){ if(!idleStart) idleStart=Date.now(); return (Date.now()-idleStart)/1000 >= IDLE_TIME; }
Â  Â  lastLatLng=latlng; idleStart=null; return false;
}

function calculateGPSSpeed(latlng){
Â  Â  const now=Date.now();
Â  Â  if(lastGPSPos && lastGPSTime){
Â  Â  Â  Â  const dist=latlng.distanceTo(lastGPSPos);
Â  Â  Â  Â  const dt=(now-lastGPSTime)/1000;
Â  Â  Â  Â  lastGPSPos=latlng; lastGPSTime=now;
Â  Â  Â  Â  return (dist/dt)*3.6;
Â  Â  }else{ lastGPSPos=latlng; lastGPSTime=now; return 0; }
}

/* ===== Predict multi-step elevation ahead (MODIFIED: 200m Lookahead) ===== */
const ELEVATION_INTERVAL=50;Â 
const LOOKAHEAD_DISTANCE=200;Â  // FIXED to 200m
let recentElevations=[];
async function predictElevationAhead(latlng,heading){
Â  Â  const R=6378137;Â 
Â  Â  const pointsAhead=[];
Â  Â  for(let d=ELEVATION_INTERVAL; d<=LOOKAHEAD_DISTANCE; d+=ELEVATION_INTERVAL){
Â  Â  Â  Â  const latRad=latlng.lat*Math.PI/180, lonRad=latlng.lng*Math.PI/180;
Â  Â  Â  Â  // Haversine formula approximation for new lat/lng (unchanged)
Â  Â  Â  Â  const newLat=latRad+(d*Math.cos(heading*Math.PI/180))/R;
Â  Â  Â  Â  const newLng=lonRad+(d*Math.sin(heading*Math.PI/180))/(R*Math.cos(latRad));
Â  Â  Â  Â  pointsAhead.push({lat:newLat*180/Math.PI,lng:newLng*180/Math.PI});
Â  Â  }
Â  Â  const elevs=await getElevations(pointsAhead);
Â  Â  recentElevations=elevs;
    // Calculate slope from first point (current) to last point (200m ahead)
    if(elevs.length < 2) return { elevs, slope: 0 };
    // We assume the first mock elevation is the current elevation, so we calculate the change over 200m.
    const elevationChange = elevs[elevs.length - 1] - elevs[0];
    const avgSlope = (elevationChange / LOOKAHEAD_DISTANCE) * 100; // Slope in percentage (meters up/down per 100 meters)
Â  Â  return {elevs, slope:avgSlope};
}

/* ===== GPS Watch (MODIFIED: Car Icon, Stable Rotation, and Initialization) ===== */
if(navigator.geolocation){
Â  Â  navigator.geolocation.watchPosition(async pos=>{
Â  Â  Â  Â  const latlng=L.latLng(pos.coords.latitude,pos.coords.longitude);
Â  Â  Â  Â  const currentSpeed = calculateGPSSpeed(latlng); // Calculate speed for stability 
    
Â  Â  Â  Â  // FIX: Only use heading if available and speed is above a minimum threshold (~5 km/h)
Â  Â  Â  Â  let heading = pos.coords.heading;
Â  Â  Â  Â  const MIN_SPEED_FOR_HEADING = 5 / 3.6; // ~1.4 m/s (5 km/h)
Â  Â  Â  Â  
Â  Â  Â  Â  // If heading is null OR speed is too low, keep the last known rotation
Â  Â  Â  Â  if (heading === null || currentSpeed < MIN_SPEED_FOR_HEADING) {
Â  Â  Â  Â  Â  Â  // Get the last known rotation from the SVG element if the marker exists
Â  Â  Â  Â  Â  Â  const carEl = document.getElementById('user-car-svg');
Â  Â  Â  Â  Â  Â  if (carEl) {
                // Extracts the number from a string like "rotate(90deg)"
Â  Â  Â  Â  Â  Â  Â  Â  const currentTransform = carEl.style.transform;
Â  Â  Â  Â  Â  Â  Â  Â  const match = currentTransform.match(/rotate\(([^)]+)deg\)/);
Â  Â  Â  Â  Â  Â  Â  Â  heading = match ? parseFloat(match[1]) : 0;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  heading = 0; // Default to North if no element found
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  if(!waypoints.length) waypoints.push(latlng); else waypoints[0]=latlng;
Â  Â  Â  Â  
Â  Â  Â  Â  // Change: Use the rotating car icon
Â  Â  Â  Â  if(!userMarker){ 
Â  Â  Â  Â  Â  Â  // Change: carIcon instead of arrowIcon
Â  Â  Â  Â  Â  Â  userMarker=L.marker(latlng,{icon:carIcon}).addTo(map); 
Â  Â  Â  Â  Â  Â  map.setView(latlng,22); // Centers map on user's actual location
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  userMarker.setLatLng(latlng);
            lockCarToCenter(); // âœ… now works 100%
Â  Â  Â  Â  }
        // ğŸ§­ Auto-follow logic: Keep car centered only if user hasnâ€™t manually moved
        // âœ… Smooth map follow + rotation (G1 MODE)
        if (autoFollow) {
            map.setView(latlng, map.getZoom(), { animate: false });

            // Apply rotation angle = -heading
            rotateMap(-heading);

        } else {
            // HYBRID MODE: If car moves more than 30m, soft recenter
            const drift = lastLatLng ? latlng.distanceTo(lastLatLng) : 0;
            if (drift > 30) {
                map.panTo(latlng, { animate: true, duration: 0.6 });
            }
        }  
        // ROTATE THE CAR SVG (The core fix for direction)
        const carEl = document.getElementById('user-car-svg');
        if (carEl) {
            // Apply the heading in degrees, correctly rotating the car
            carEl.style.transform = `rotate(${heading}deg)`; 
        }
        if (speechSynthesis.pending && !speechSynthesis.speaking)
          speechSynthesis.resume();

Â  Â  Â  Â  await adaptiveAIDashboard(latlng,heading);
Â  Â  Â  Â  checkOffRoute(latlng);
Â  Â  },()=>console.warn("GPS unavailable"),{enableHighAccuracy:true, maximumAge: 1000, timeout: 5000});
}

let driverCountry = null;

async function updateDriverCountry(latlng) {
  try {
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&zoom=5&addressdetails=1`;
    const res = await fetch(url);
    const data = await res.json();
    driverCountry = data.address && (data.address.country_code || "").toUpperCase();
    console.log("ğŸ“ Driver country detected:", driverCountry);
  } catch (err) {
    console.warn("Country fetch failed:", err);
  }
}
/* ===== Off-route adaptation (Unchanged) ===== */
async function checkOffRoute(latlng) {
    if (!routes.length) return;

    const active = routes[activeRouteIndex ?? 0];
    if (!active || !active.steps) return;

    let minDist = Infinity;
    active.steps.forEach(s => {
        const d = latlng.distanceTo([s.lat, s.lng]);
        if (d < minDist) minDist = d;
    });

    // âœ… Only update existing route, DO NOT create a new one
    if (minDist > 30) {
        console.log("Off-route â†’ updating start point");

        if (active.rc && active.rc.getWaypoints) {
            const wps = active.rc.getWaypoints();
            wps[0].latLng = latlng;  
            active.rc.setWaypoints(wps);  
        }
    }
}


/* === English Name Translator (Nominatim Reverse Lookup) === */
async function getEnglishName(lat, lon) {
  try {
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1&accept-language=en`;
    const res = await fetch(url, { cache: "no-store" });
    const data = await res.json();
    // Prefer explicit road name, fallback to display_name
    return data.address?.road || data.display_name || "";
  } catch (err) {
    console.warn("English name lookup failed:", err);
    return "";
  }
}

/* ===== Route creation & step-box integration (MODIFIED: Deletion Logic) ===== */
async function createRoute(start, end, color, marker = null, index = null) {
    const routeIndex = index !== null ? index : routes.length;
    const displayIndex = routeIndex + 1;
    const endKey = `${end.lat.toFixed(6)},${end.lng.toFixed(6)}`;

    // âœ… prevent duplicate routes to same destination
    const exists = routes.find(r => r.endKey === endKey);
    if (exists) return;

    const routeColor = color || colors[routeIndex % colors.length];

    // âœ… remove old rc/group if this index is being reused
    const old = routes.find(r => r.routeIndex === routeIndex);
    if (old) {
        try { map.removeControl(old.rc); } catch {}
        try { map.removeLayer(old.group); } catch {}
    }

    const rc = L.Routing.control({
        waypoints: [start, end],
        router: L.Routing.osrmv1({ serviceUrl: "https://router.project-osrm.org/route/v1" }),
        show: false,
        addWaypoints: false,
        createMarker: () => null,
        lineOptions: { styles: [{ color: routeColor, weight: 5, opacity: 0.9 }] }
    }).addTo(map);

    const group = L.layerGroup().addTo(map);
    document.querySelectorAll(".leaflet-routing-container").forEach(el => el.style.display = "none");

    // âœ… BOX HANDLING (re-use or create)
    let box = document.getElementById(`route-box-${routeIndex}`);
    let header, content;

    if (!box) {
        box = document.createElement("div");
        box.className = "route-box";
        box.id = `route-box-${routeIndex}`;

        header = document.createElement("div");
        content = document.createElement("div");
        content.className = "route-content";
        content.style.display = "block";

        box.appendChild(header);
        box.appendChild(content);
        document.getElementById("routePanel").appendChild(box);
    } else {
        header = box.querySelector(".route-header");
        content = box.querySelector(".route-content");
    }

    // âœ… update header
    header.className = "route-header";
    header.style.background = routeColor;
    header.innerHTML = `
        <b>Route ${displayIndex}</b>
        <span id="route-distance-${routeIndex}" style="font-weight:normal;">Calculating...</span>
        <button class="route-delete" style="background:#ff4c4c;border:none;color:#fff;border-radius:50%;width:22px;height:22px;">âœ•</button>
    `;
    header.onclick = () => content.style.display = content.style.display === "block" ? "none" : "block";

    // âœ… delete route handler
    header.querySelector("button").onclick = () => {
        // Stop speech immediately
        try { speechSynthesis.cancel(); } catch {}

        // Remove route visuals
        try { map.removeControl(rc); } catch {}
        try { map.removeLayer(group); } catch {}

        // Remove waypoint marker
        if (marker) {
            const mIndex = waypointMarkers.indexOf(marker);
            if (mIndex !== -1) {
                map.removeLayer(marker);
                waypointMarkers.splice(mIndex, 1);
                waypoints.splice(mIndex + 1, 1);
            }
        }

        // Remove box
        box.remove();
        // âœ… HARD STOP step engine
        activeRouteIndex = null;
        currentStepIndex = 0;
        nextStepReady = true;

        // âœ… Clear speech memory so steps won't repeat
        lastSpeech.type = null;
        lastSpeech.text = "";

        // Remove from route array
        routes = routes.filter(r => r.routeIndex !== routeIndex);

        // Rebuild the chain
        rebuildRoutes();

        // âœ… NEW: Immediately activate the next available route
        if (routes.length > 0) {
            activeRouteIndex = 0;
            currentStepIndex = 0;
            nextStepReady = true;

            // Speak first step of new route instantly
            setTimeout(() => {
                try { speakCurrentStep(); } catch {}
            }, 300);
        } else {
            activeRouteIndex = null;
            currentStepIndex = 0;
            // âœ… show fresh eco driving tip instead of "no route"
            document.getElementById("ai-tip").textContent = "Tip: " + ecoAdvisor(800, lastSlope, "").tip;

        }
    };


    // âœ… when OSRM returns steps
    rc.on("routesfound", async e => {
        const r = e.routes[0];
        const coords = r.coordinates.map(c => ({ lat: c.lat, lng: c.lng }));
        const elevs = await getElevations(coords);

        content.innerHTML = "";
        const steps = [];

        r.instructions.forEach((s, i) => {
            const idxStart = s.index;
            const idxEnd = r.instructions[i + 1] ? r.instructions[i + 1].index : coords.length;

            const seg = coords.slice(idxStart, idxEnd).map(c => [c.lat, c.lng]);
            const elev = elevs[idxStart] || 0;

            const line = L.polyline(seg, { color: routeColor, weight: 5, opacity: 0.8 }).addTo(group);

            const div = document.createElement("div");
            div.className = "route-step";
            div.onmouseenter = () => {
                line.setStyle({ weight: 9, opacity: 1, color: "#FFFF33" });
            };
            div.onmouseleave = () => {
                line.setStyle({ weight: 5, opacity: 0.9, color: routeColor });
            };
            div.innerHTML = `<b>${s.text}</b><div>${(s.distance / 1000).toFixed(2)} km | Elev ${elev.toFixed(1)} m`;
            content.appendChild(div);

            steps.push({
                lat: coords[idxStart].lat,
                lng: coords[idxStart].lng,
                text: s.text,
                elev,
                distance: s.distance,
                element: div,
                lineLayer: line
            });
        });

        // âœ… update or push to routes array
        const existing = routes.find(r => r.routeIndex === routeIndex);
        if (existing) {
            existing.rc = rc;
            existing.group = group;
            existing.steps = steps;
            existing.endKey = endKey;
            existing.totalDistance = r.summary.totalDistance;
        } else {
            routes.push({
                rc, group, steps, endKey,
                routeIndex, totalDistance: r.summary.totalDistance
            });
        }

        document.getElementById(`route-distance-${routeIndex}`).textContent =
            `${(r.summary.totalDistance / 1000).toFixed(1)} km total`;

        if (activeRouteIndex === null) {
            activeRouteIndex = routeIndex;
            currentStepIndex = 0;
            speakCurrentStep();
        }
    });
}

/* ===== Add waypoint on map click (Unchanged) ===== */
map.on('click', async e => {
    const latlng = e.latlng;

    // âœ… 1. Decide start point for preview
    let startPoint = null;

    // If any active route exists â†’ start from last step of the LAST route
    if (routes.length > 0) {
        const lastRoute = routes[routes.length - 1];
        const lastSteps = lastRoute.steps;
        if (lastSteps.length > 0) {
            const lastStep = lastSteps[lastSteps.length - 1];
            startPoint = L.latLng(lastStep.lat, lastStep.lng);
        }
    }

    // If no routes â†’ start from driver
    if (!startPoint) {
        startPoint = userMarker ? userMarker.getLatLng() : map.getCenter();
    }

    // âœ… 2. Build preview WITHOUT pushing to waypoints
    openPreviewTo(latlng, "Pinned location", true);
    preview.start = startPoint;   // Override preview start properly
});


/* ===== Rebuild Routes (MODIFIED: to re-index and ensure no duplicates) ===== */
function rebuildRoutes() {
    // âœ… Always start from driver
    const driver = userMarker ? userMarker.getLatLng() : map.getCenter();

    const validWaypoints = [driver];
    const validMarkers = [];

    // âœ… keep only markers still on map
    waypointMarkers.forEach((m, i) => {
        if (map.hasLayer(m)) {
            validWaypoints.push(m.getLatLng());
            validMarkers.push(m);
        }
    });

    // âœ… reset arrays
    waypoints.length = 0;
    waypointMarkers.length = 0;
    waypoints.push(...validWaypoints);
    waypointMarkers.push(...validMarkers);

    // âœ… remove old routes
    routes.forEach(r => {
        try { map.removeControl(r.rc); } catch {}
        try { map.removeLayer(r.group); } catch {}
    });
    routes = [];
    document.getElementById("routePanel").innerHTML = "";

    // âœ… no chain if only one point
    if (waypoints.length < 2) return;

    // âœ… rebuild properly: Driver â†’ WP1 â†’ WP2 â†’ â€¦
    for (let i = 1; i < waypoints.length; i++) {
        createRoute(
            waypoints[i - 1],
            waypoints[i],
            colors[(i - 1) % colors.length],
            waypointMarkers[i - 1],
            i - 1
        );
    }
}

/* ===== Map Toggle (Unchanged) ===== */
let mapFull=false;
document.getElementById("map-toggle").addEventListener("click",()=>{
Â  const mapContainer=document.querySelector(".map-container");
Â  const button=document.getElementById("map-toggle");
Â  if(!mapFull){
Â  Â  mapContainer.style.position="fixed"; mapContainer.style.top="0"; mapContainer.style.left="0"; mapContainer.style.width="100vw"; mapContainer.style.height="100vh"; mapContainer.style.zIndex="2000";
Â  Â  button.innerText="Restore Map"; mapFull=true; setTimeout(()=>map.invalidateSize(),300);
Â  }else{
Â  Â  mapContainer.style.position=""; mapContainer.style.width=""; mapContainer.style.height=""; mapContainer.style.zIndex="";
Â  Â  button.innerText="Full Map"; mapFull=false; setTimeout(()=>map.invalidateSize(),300);
Â  }
});

/* ===== Detect Map Interaction (to disable auto-follow) ===== */
map.on('dragstart zoomstart', () => {
  autoFollow = false; // Stop following when user interacts
});

/* ===== Locate (Target) Button Functionality (Toggle Follow Mode) ===== */
const locateBtn = document.getElementById("locate-btn");
locateBtn.addEventListener("click", () => {
  if (!userMarker) {
    alert("User location not available yet!");
    return;
  }

  // Toggle follow mode
  autoFollow = !autoFollow;

  const userPos = userMarker.getLatLng();
  map.setView(userPos, 19, { animate: true });

  // This prevents duplicate boxes and repeated boxes for the same destination.
  const routeBoxByIndex = new Map();     // routeIndex -> { box, header, content }
  const routeIndexByEndKey = new Map();  // endKey     -> routeIndex

  function getOrCreateRouteBox(routeIndex, displayIndex, routeColor, endKey) {
    let ui = routeBoxByIndex.get(routeIndex);
    if (!ui) {
      const box = document.createElement('div');
      box.className = 'route-box';
      box.id = `route-box-${routeIndex}`;
      box.dataset.endkey = endKey;

      const header = document.createElement('div');
      header.className = 'route-header';

      const content = document.createElement('div');
      content.className = 'route-content';
      content.style.display = 'block';

      box.appendChild(header);
      box.appendChild(content);
      document.getElementById('routePanel').appendChild(box);

      ui = { box, header, content };
      routeBoxByIndex.set(routeIndex, ui);
    }

    // (Re)paint header consistently
    ui.header.style.background = routeColor;
    ui.header.innerHTML = `
      <b>Route ${displayIndex}</b>
      <span id="route-distance-${routeIndex}" style="font-weight:normal;">Calculating...</span>
      <button class="route-delete" style="background:#ff4c4c;border:none;color:#fff;border-radius:50%;width:22px;height:22px;">âœ•</button>
    `;
    ui.header.onclick = () => {
      ui.content.style.display = ui.content.style.display === 'block' ? 'none' : 'block';
    };

    ui.box.dataset.endkey = endKey;
    routeIndexByEndKey.set(endKey, routeIndex);
    return ui;
  }

  // Button feedback animation
  locateBtn.style.transform = "scale(0.9)";
  setTimeout(() => locateBtn.style.transform = "scale(1)", 150);

  // Visual state feedback
  if (autoFollow) {
    locateBtn.style.background = "#00b300"; // Green = tracking active
    locateBtn.title = "Following car (tap to stop)";
  } else {
    locateBtn.style.background = "#1e90ff"; // Blue = tracking off
    locateBtn.title = "Recenter to my location";
  }
});


/* ===== Search Suggestions/Voice Search (Unchanged) ===== */
const input = document.getElementById("searchInput");
const suggestBox = document.getElementById("suggestBox");
let results = [];
let searchTimer = null;

async function getSearchResults(query) {
    const center = userMarker ? userMarker.getLatLng() : map.getCenter();
    const lang = driverCountry ? driverCountry.toLowerCase() : "en";
    // âœ… Lat/Lng input detection
    const latlngMatch = query.match(/^([-]?[0-9]+\.[0-9]+)[,\s]+([-]?[0-9]+\.[0-9]+)$/);
    if (latlngMatch) {
        return [{
            name: "Pinned Location",
            display_name: "Manual coordinate input",
            lat: parseFloat(latlngMatch[1]),
            lon: parseFloat(latlngMatch[2]),
            score: 100
        }];
    }
    let allResults = [];

    // 1ï¸âƒ£ Photon search
    try {
        const photonURL = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&lat=${center.lat}&lon=${center.lng}&limit=8&lang=${lang}`;
        const ph = await fetch(photonURL);
        const json = await ph.json();
        if (json.features) {
            json.features.forEach(f => {
                allResults.push({
                    name: f.properties.name || f.properties.street || f.properties.locality || "Unnamed",
                    display_name: [f.properties.name, f.properties.city, f.properties.country]
                        .filter(Boolean).join(", "),
                    lat: f.geometry.coordinates[1],
                    lon: f.geometry.coordinates[0],
                    score: 50
                });
            });
        }
    } catch (err) {}

    // 2ï¸âƒ£ Nominatim search
    try {
        const nomURL = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=8&addressdetails=1&accept-language=${lang}`;
        const nm = await fetch(nomURL);
        const data = await nm.json();
        data.forEach(f => {
            allResults.push({
                name: f.display_name.split(",")[0],
                display_name: f.display_name,
                lat: parseFloat(f.lat),
                lon: parseFloat(f.lon),
                score: 70
            });
        });
    } catch (err) {}

    // 3ï¸âƒ£ geocode.maps.co â€” POI/category search
    try {
        const mURL = `https://geocode.maps.co/search?q=${encodeURIComponent(query)}`;
        const gr = await fetch(mURL);
        const gd = await gr.json();
        gd.forEach(f => {
            allResults.push({
                name: f.display_name.split(",")[0],
                display_name: f.display_name,
                lat: parseFloat(f.lat),
                lon: parseFloat(f.lon),
                score: 90
            });
        });
    } catch (err) {}

    // âœ… SORT by score DESC (most accurate first)
    allResults.sort((a, b) => b.score - a.score);

    return allResults.slice(0, 10);
}

// Debounced input listener for smooth UX
input.oninput = () => {
  const q = input.value.trim();
  if (searchTimer) clearTimeout(searchTimer);
  if (!q) return (suggestBox.style.display = "none");

  searchTimer = setTimeout(async () => {
    const data = await getSearchResults(q);
    results = data;
    suggestBox.innerHTML = "";
    if (!data.length) {
      suggestBox.style.display = "none";
      return;
    }

    data.forEach((f, i) => {
      const div = document.createElement("div");
      div.className = "suggest-item";
      div.innerHTML = `<b>${f.name}</b><div style="font-size:12px;color:#bbb;">${f.display_name}</div>`;
      div.onclick = () => selectResult(i);
      suggestBox.appendChild(div);
    });
    suggestBox.style.display = "block";
  }, 300); // debounce for 300 ms
};

document.addEventListener("click", e => {
  if (!suggestBox.contains(e.target) && e.target !== input)
    suggestBox.style.display = "none";
});

function selectResult(i) {
  const f = results[i];
  if (!f) return;
  const latlng = L.latLng(f.lat, f.lon);
  // âœ… 1. Build PREVIEW route instead of creating final route
  openPreviewTo(latlng, f.name, true);
  // âœ… 2. Do NOT push waypoint immediately (wait until Start button)
  input.value = "";
  suggestBox.style.display = "none";
  // âœ… 3. Smooth camera movement to preview destination
  map.flyTo(latlng, 16, { animate: true, duration: 1.2 });
}

const micBtn = document.getElementById('micBtn');

micBtn.onclick = async () => {
Â  if (!('webkitSpeechRecognition' in window)) {
Â  Â  alert('Speech Recognition not supported on this browser');
Â  Â  return;
Â  }

Â  try {
Â  Â  // Ask for microphone permission explicitly (like location)
Â  Â  await navigator.mediaDevices.getUserMedia({ audio: true });

Â  Â  const recog = new webkitSpeechRecognition();
Â  Â  recog.lang = 'en-US';
Â  Â  recog.interimResults = false;
Â  Â  recog.maxAlternatives = 1;

Â  Â  micBtn.textContent = 'ğŸ™ï¸ Listening...';
Â  Â  recog.start();

Â  Â  recog.onresult = (e) => {
Â  Â  Â  const text = e.results[0][0].transcript;
Â  Â  Â  input.value = text;
Â  Â  Â  input.dispatchEvent(new Event('input'));
Â  Â  };

Â  Â  recog.onerror = (err) => {
Â  Â  Â  console.warn('Speech recognition error:', err);
Â  Â  Â  micBtn.textContent = 'ğŸ¤';
Â  Â  };

Â  Â  recog.onend = () => {
Â  Â  Â  micBtn.textContent = 'ğŸ¤';
Â  Â  };

Â  } catch (err) {
Â  Â  // Permission denied or mic unavailable
Â  Â  console.error('Microphone access denied:', err);
Â  Â  alert('Please allow microphone permission to use voice search.');
Â  }
};

</script>
</body>
</html>
